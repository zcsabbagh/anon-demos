"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserbaseCodeGenerator = void 0;
const events_1 = require("events");
const generator_1 = require("./generator");
const time_1 = require("./time");
const timeout_runner_1 = require("./timeout-runner");
const css_utils_1 = require("./css-utils");
const crypto_1 = require("./crypto");
const utils_1 = require("./utils");
const javascript_generator_1 = require("./javascript-generator");
class BrowserbaseCodeGenerator extends events_1.EventEmitter {
    _context;
    // This is used in the playground to bypass the verification step since it doesnt work
    // in the browser
    _skipVerify = false;
    _enabled;
    _generator;
    _pageAliases = new Map();
    _lastPopupOrdinal = 0;
    _lastDialogOrdinal = -1;
    _lastDownloadOrdinal = -1;
    _timers = new Set();
    _javascriptGenerator;
    constructor(context, options) {
        super();
        this._context = context;
        this._enabled = options?.enabled ?? false;
        this._generator = new generator_1.CodeGenerator('chromium', this._enabled, {}, {}, undefined, undefined);
        this._javascriptGenerator = new javascript_generator_1.JavaScriptLanguageGenerator(false);
        this._generator.on('change', () => {
            const { header, footer, actions, text } = this._generator.generateStructure(this._javascriptGenerator);
            this.emit('action', { actions });
        });
    }
    static async init(context, options) {
        const browserbaseCodeGenerator = new BrowserbaseCodeGenerator(context, options);
        await browserbaseCodeGenerator.install();
        return browserbaseCodeGenerator;
    }
    setEnabled(enabled) {
        this._enabled = enabled;
        this._generator.setEnabled(enabled);
    }
    async install() {
        if (!this._skipVerify) {
            const codegenMode = await this._ensureCodegenEnabled();
            if (!codegenMode) {
                throw new Error('Failed to install generator: codegenMode not enabled on this session');
            }
        }
        this._context.on('page', (page) => {
            this._onPage(page);
        });
        for (const page of this._context.pages()) {
            this._onPage(page);
        }
        this._context.on('dialog', (dialog) => {
            this._onDialog(dialog.page());
        });
        await this._context.exposeBinding('__bb_recorderPerformAction', (source, action) => this._performAction(source.frame, action));
        await this._context.exposeBinding('__bb_recorderRecordAction', (source, action) => this._recordAction(source.frame, action));
        await this._context.exposeBinding('__bb_recorderEnabled', (_source) => true);
    }
    _onDialog(page) {
        const pageAlias = this._pageAliases.get(page);
        ++this._lastDialogOrdinal;
        this._generator.signal(pageAlias, page.mainFrame(), {
            name: 'dialog',
            dialogAlias: this._lastDialogOrdinal
                ? String(this._lastDialogOrdinal)
                : '',
        });
    }
    // when a browser is created with record mode it will add a global variable to the page
    // this function checks if the global variable is present and returns true if it is
    async _ensureCodegenEnabled() {
        const enabledState = this._enabled;
        // disable generator so we dont capture these actions
        if (enabledState) {
            this.setEnabled(false);
        }
        const page = await this._context.newPage();
        await page.waitForLoadState('domcontentloaded');
        const codegenMode = await page.evaluate(() => {
            // @ts-expect-error
            if (window.__bb_codegenEnabled) {
                // @ts-expect-error
                return window.__bb_codegenEnabled();
            }
            return false;
        });
        await page.close();
        // re-enable generator
        if (enabledState) {
            this.setEnabled(true);
        }
        return codegenMode;
    }
    async _onPage(page) {
        const frame = page.mainFrame();
        page.on('close', () => {
            this._generator.addAction({
                frame: this._describeMainFrame(page),
                committed: true,
                action: {
                    name: 'closePage',
                    signals: [],
                },
            });
            this._pageAliases.delete(page);
        });
        // @ts-ignore
        frame._eventEmitter.on('navigated', (event) => {
            this._onFrameNavigated(frame, page);
        });
        page.on('download', () => this._onDownload(page));
        const suffix = this._pageAliases.size
            ? String(++this._lastPopupOrdinal)
            : '';
        const pageAlias = 'page' + suffix;
        this._pageAliases.set(page, pageAlias);
        const opener = await page.opener();
        if (opener) {
            this._onPopup(opener, page);
        }
        else {
            this._generator.addAction({
                frame: this._describeMainFrame(page),
                committed: true,
                action: {
                    name: 'openPage',
                    url: page.mainFrame().url(),
                    signals: [],
                },
            });
        }
    }
    _describeMainFrame(page) {
        return {
            pageAlias: this._pageAliases.get(page),
            isMainFrame: true,
        };
    }
    async _describeFrame(frame) {
        // @ts-expect-error
        const page = frame._page;
        const pageAlias = this._pageAliases.get(page);
        const chain = [];
        for (let ancestor = frame; ancestor; ancestor = ancestor.parentFrame())
            chain.push(ancestor);
        chain.reverse();
        if (chain.length === 1)
            return this._describeMainFrame(page);
        const selectorPromises = [];
        for (let i = 0; i < chain.length - 1; i++)
            selectorPromises.push(findFrameSelector(chain[i + 1]));
        const result = await (0, timeout_runner_1.raceAgainstDeadline)(() => Promise.all(selectorPromises), (0, time_1.monotonicTime)() + 2000);
        if (!result.timedOut &&
            // @ts-expect-error
            result.result.every((selector) => !!selector)) {
            return {
                pageAlias,
                isMainFrame: false,
                // @ts-expect-error
                selectorsChain: result.result,
            };
        }
        // Best effort to find a selector for the frame.
        const selectorsChain = [];
        for (let i = 0; i < chain.length - 1; i++) {
            if (chain[i].name())
                selectorsChain.push(`iframe[name=${(0, css_utils_1.quoteCSSAttributeValue)(chain[i].name())}]`);
            else
                selectorsChain.push(`iframe[src=${(0, css_utils_1.quoteCSSAttributeValue)(chain[i].url())}]`);
        }
        return {
            pageAlias,
            isMainFrame: false,
            selectorsChain,
        };
    }
    async _performAction(frame, action) {
        // console.log('perform action', action)
        // Commit last action so that no further signals are added to it.
        this._generator.commitLastAction();
        const frameDescription = await this._describeFrame(frame);
        const actionInContext = {
            frame: frameDescription,
            action,
        };
        const perform = async (action, params, cb) => {
            const callMetadata = {
                id: `call@${(0, crypto_1.createGuid)()}`,
                apiName: 'frame.' + action,
                // @ts-expect-error
                objectId: frame._guid,
                // @ts-expect-error
                pageId: frame._page._guid,
                // @ts-expect-error
                frameId: frame._guid,
                startTime: (0, time_1.monotonicTime)(),
                endTime: 0,
                type: 'Frame',
                method: action,
                params,
                log: [],
            };
            this._generator.willPerformAction(actionInContext);
            //// console.log('will perform action', actionInContext)
            try {
                //await frame.instrumentation.onBeforeCall(frame, callMetadata)
                await cb(callMetadata);
            }
            catch (e) {
                console.error('error performing action', e);
                callMetadata.endTime = (0, time_1.monotonicTime)();
                //await frame.instrumentation.onAfterCall(frame, callMetadata)
                this._generator.performedActionFailed(actionInContext);
                return;
            }
            callMetadata.endTime = (0, time_1.monotonicTime)();
            //await frame.instrumentation.onAfterCall(frame, callMetadata)
            this._setCommittedAfterTimeout(actionInContext);
            this._generator.didPerformAction(actionInContext);
            //console.log('did perform action', actionInContext)
        };
        const kActionTimeout = 5000;
        if (action.name === 'click') {
            const { options } = (0, utils_1.toClickOptions)(action);
            await perform('click', { selector: action.selector }, (callMetadata) => {
                return frame.click(action.selector, {
                    ...options,
                    force: true,
                    timeout: kActionTimeout,
                    strict: true,
                });
            });
        }
        if (action.name === 'press') {
            const modifiers = (0, utils_1.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join('+');
            await perform('press', { selector: action.selector, key: shortcut }, (callMetadata) => frame.press(action.selector, shortcut, {
                timeout: kActionTimeout,
                strict: true,
            }));
        }
        if (action.name === 'check')
            await perform('check', { selector: action.selector }, (callMetadata) => frame.check(action.selector, {
                timeout: kActionTimeout,
                strict: true,
            }));
        if (action.name === 'uncheck')
            await perform('uncheck', { selector: action.selector }, (callMetadata) => frame.uncheck(action.selector, {
                timeout: kActionTimeout,
                strict: true,
            }));
        if (action.name === 'select') {
            const values = action.options.map((value) => ({ value }));
            await perform('selectOption', { selector: action.selector, values }, (callMetadata) => frame.selectOption(action.selector, values, {
                timeout: kActionTimeout,
                strict: true,
            }));
        }
    }
    async _recordAction(frame, action) {
        // console.log('record action', action)
        // Commit last action so that no further signals are added to it.
        this._generator.commitLastAction();
        // console.log('committed action')
        const frameDescription = await this._describeFrame(frame);
        // console.log('described frame')
        const actionInContext = {
            frame: frameDescription,
            action,
        };
        this._setCommittedAfterTimeout(actionInContext);
        // console.log('committed after timeout')
        this._generator.addAction(actionInContext);
        // console.log('action added')
    }
    _setCommittedAfterTimeout(actionInContext) {
        const timer = setTimeout(() => {
            // Commit the action after 5 seconds so that no further signals are added to it.
            actionInContext.committed = true;
            this._timers.delete(timer);
        }, 5000);
        this._timers.add(timer);
    }
    _onFrameNavigated(frame, page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, frame, {
            name: 'navigation',
            url: frame.url(),
        });
    }
    _onPopup(page, popup) {
        const pageAlias = this._pageAliases.get(page);
        const popupAlias = this._pageAliases.get(popup);
        this._generator.signal(pageAlias, page.mainFrame(), {
            name: 'popup',
            popupAlias,
        });
    }
    _onDownload(page) {
        const pageAlias = this._pageAliases.get(page);
        ++this._lastDownloadOrdinal;
        this._generator.signal(pageAlias, page.mainFrame(), {
            name: 'download',
            downloadAlias: this._lastDownloadOrdinal
                ? String(this._lastDownloadOrdinal)
                : '',
        });
    }
}
exports.BrowserbaseCodeGenerator = BrowserbaseCodeGenerator;
async function findFrameSelector(frame) {
    try {
        const parent = frame.parentFrame();
        const frameElement = await frame.frameElement();
        if (!frameElement || !parent)
            return;
        const selector = await parent.evaluate((element) => {
            //@ts-expect-error
            return window.__bb_injectedScript.generateSelectorSimple(element, {
                testIdAttributeName: '',
                omitInternalEngines: true,
            });
        }, frameElement);
        return selector;
    }
    catch (e) { }
}
