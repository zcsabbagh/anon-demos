"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserbaseCodeGenerator = exports.BrowserbaseAISDK = exports.Browserbase = void 0;
const puppeteer_core_1 = __importDefault(require("puppeteer-core"));
const ai_sdk_js_1 = __importDefault(require("./integrations/ai-sdk.js"));
exports.BrowserbaseAISDK = ai_sdk_js_1.default;
const recorder_1 = require("./recorder/recorder");
Object.defineProperty(exports, "BrowserbaseCodeGenerator", { enumerable: true, get: function () { return recorder_1.BrowserbaseCodeGenerator; } });
class Browserbase {
    apiKey;
    projectId;
    baseAPIURL;
    baseConnectURL;
    constructor(options = {}) {
        this.apiKey = options.apiKey || process.env.BROWSERBASE_API_KEY;
        this.projectId = options.projectId || process.env.BROWSERBASE_PROJECT_ID;
        this.baseAPIURL = options.baseURL || 'https://api.browserbase.com';
        this.baseConnectURL =
            options.baseConnectURL || 'wss://connect.browserbase.com';
    }
    getConnectURL({ sessionId, proxy = false } = {}) {
        return `${this.baseConnectURL}?apiKey=${this.apiKey}${sessionId ? `&sessionId=${sessionId}` : ''}${proxy ? `&enableProxy=true` : ''}`;
    }
    async listSessions() {
        const response = await fetch(`${this.baseAPIURL}/v1/sessions`, {
            headers: {
                'x-bb-api-key': this.apiKey,
                'Content-Type': 'application/json',
            },
        });
        return await response.json();
    }
    async createSession(options) {
        const mergedOptions = { projectId: this.projectId, ...options };
        if (!mergedOptions.projectId) {
            throw new Error('a projectId is missing: use the options.projectId or BROWSERBASE_PROJECT_ID environment variable to set one.');
        }
        const response = await fetch(`${this.baseAPIURL}/v1/sessions`, {
            method: 'POST',
            headers: {
                'x-bb-api-key': this.apiKey,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(mergedOptions),
        });
        return await response.json();
    }
    async completeSession(sessionId) {
        if (!sessionId || sessionId === '') {
            throw new Error('sessionId is required');
        }
        if (!this.projectId) {
            throw new Error('a projectId is missing: use the options.projectId or BROWSERBASE_PROJECT_ID environment variable to set one.');
        }
        const response = await fetch(`${this.baseAPIURL}/v1/sessions/${sessionId}`, {
            method: 'POST',
            headers: {
                'x-bb-api-key': this.apiKey,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                projectId: this.projectId,
                status: 'REQUEST_RELEASE',
            }),
        });
        return await response.json();
    }
    async getSession(sessionId) {
        const response = await fetch(`${this.baseAPIURL}/v1/sessions/${sessionId}`, {
            headers: {
                'x-bb-api-key': this.apiKey,
                'Content-Type': 'application/json',
            },
        });
        return await response.json();
    }
    async getSessionRecording(sessionId) {
        const response = await fetch(`${this.baseAPIURL}/v1/sessions/${sessionId}/recording`, {
            headers: {
                'x-bb-api-key': this.apiKey,
                'Content-Type': 'application/json',
            },
        });
        return await response.json();
    }
    async getSessionDownloads(sessionId, retryInterval = 2000, retryCount = 2) {
        return new Promise((resolve, reject) => {
            const fetchDownload = async () => {
                const response = await fetch(`${this.baseAPIURL}/v1/sessions/${sessionId}/downloads`, {
                    method: 'GET',
                    headers: {
                        'x-bb-api-key': this.apiKey,
                    },
                });
                const arrayBuffer = await response.arrayBuffer();
                if (arrayBuffer.byteLength > 0) {
                    resolve(Buffer.from(arrayBuffer));
                }
                else {
                    retryCount--;
                    if (retryCount <= 0) {
                        reject();
                    }
                    setTimeout(fetchDownload, retryInterval);
                }
            };
            fetchDownload();
        });
    }
    async getDebugConnectionURLs(sessionId) {
        const response = await fetch(`${this.baseAPIURL}/v1/sessions/${sessionId}/debug`, {
            method: 'GET',
            headers: {
                'x-bb-api-key': this.apiKey,
                'Content-Type': 'application/json',
            },
        });
        const json = await response.json();
        return json;
    }
    async getSessionLogs(sessionId) {
        const response = await fetch(`${this.baseAPIURL}/v1/sessions/${sessionId}/logs`, {
            headers: {
                'x-bb-api-key': this.apiKey,
                'Content-Type': 'application/json',
            },
        });
        return await response.json();
    }
    load(url, options = {}) {
        if (typeof url === 'string') {
            return this.loadURL(url, options);
        }
        else if (Array.isArray(url)) {
            return this.loadURLs(url, options);
        }
        else {
            throw new TypeError('Input must be a URL string or array of URLs');
        }
    }
    async loadURL(url, options = {}) {
        if (!url) {
            throw new Error('Page URL was not provided');
        }
        const browser = await puppeteer_core_1.default.connect({
            browserWSEndpoint: this.getConnectURL({
                sessionId: options.sessionId,
                proxy: options.proxy,
            }),
        });
        const pages = await browser.pages();
        const page = pages[0];
        await page.goto(url);
        let html = await page.content();
        if (options.textContent) {
            const readable = await page.evaluate(`
        import('https://cdn.skypack.dev/@mozilla/readability').then(readability => {
          return new readability.Readability(document).parse()
        })`);
            html = `${readable.title}\n${readable.textContent}`;
        }
        await browser.close();
        return html;
    }
    async *loadURLs(urls, options = {}) {
        if (!urls.length) {
            throw new Error('Page URLs were not provided');
        }
        const browser = await puppeteer_core_1.default.connect({
            browserWSEndpoint: this.getConnectURL({
                sessionId: options.sessionId,
                proxy: options.proxy,
            }),
        });
        const pages = await browser.pages();
        const page = pages[0];
        for (const url of urls) {
            await page.goto(url);
            let html = await page.content();
            if (options.textContent) {
                const readable = await page.evaluate(`
          import('https://cdn.skypack.dev/@mozilla/readability').then(readability => {
            return new readability.Readability(document).parse()
          })`);
                html = `${readable.title}\n${readable.textContent}`;
            }
            yield html;
        }
        await browser.close();
    }
    async screenshot(url, options = { fullPage: false }) {
        if (!url) {
            throw new Error('Page URL was not provided');
        }
        const browser = await puppeteer_core_1.default.connect({
            browserWSEndpoint: this.getConnectURL({
                sessionId: options.sessionId,
                proxy: options.proxy,
            }),
        });
        const pages = await browser.pages();
        const page = pages[0];
        await page.goto(url);
        const screenshot = await page.screenshot({ fullPage: options.fullPage });
        await browser.close();
        return screenshot;
    }
    async createContext() {
        const response = await fetch(`${this.baseAPIURL}/v1/contexts`, {
            method: 'POST',
            headers: {
                'x-bb-api-key': this.apiKey,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ projectId: this.projectId }),
        });
        if (!response.ok) {
            throw new Error('Failed to create context');
        }
        const data = await response.json();
        return data;
    }
}
exports.default = Browserbase;
exports.Browserbase = Browserbase;
