'use strict';

/**
 * Automates the process of adding AirPods to the cart on Amazon.
 *
 * @param networkHelper - Helper object for network-related operations
 * @returns A function that takes a Playwright Page object that is on the home page of Amazon and performs the automation
 */
const demoAddHeadphonesToCart = (networkHelper) => async (page) => {
    await searchItem(networkHelper, "Airpods")(page);
    await networkHelper.takeScreenshot(page, "amazon", "search_results");
    await addItemToCartOnProductPage(networkHelper, page);
    await networkHelper.takeScreenshot(page, "amazon", "addCart");
    await navigateToCheckoutPage(networkHelper, page);
    await networkHelper.takeScreenshot(page, "amazon", "checkout");
    await submitCheckoutOnCheckoutPage(networkHelper, page);
    await networkHelper.takeScreenshot(page, "amazon", "orderSubmitted");
};
/**
 * Retrieves all orders from the Amazon account.
 *
 * @param networkHelper - Helper object for network-related operations
 * @returns A function that takes a Playwright Page object that is on the home page of Amazon and returns an array of OrderInfo
 */
const getAllOrders = (networkHelper) => async (page) => {
    await navigateToAccountPage(networkHelper, page);
    await navigateToOrdersPage(networkHelper, page);
    const orders = await extractOrdersInfo(networkHelper, page);
    return orders;
};
/**
 * Searches for a specified item on Amazon.
 *
 * @param networkHelper - Helper object for network-related operations
 * @param item - The item to search for
 * @returns A function that takes a Playwright Page object that is on the home page of Amazon and performs the search
 */
const searchItem = (networkHelper, item) => async (page) => {
    await networkHelper.waitForNetworkIdle(page);
    await page.focus("#twotabsearchtextbox");
    await page.keyboard.type(item);
    await page.keyboard.press("Enter");
    await clickFirstVisibleItemOnSearchPage(networkHelper, page);
};
/**
/**
 * Adds the current item to the cart from the product page.
 * Note: This function may not work for subscription items like medication, food or clothing
 *
 * @param networkHelper - Helper object for network-related operations
 * @param page - Playwright Page object that should be on an Amazon product page
 */
const addItemToCartOnProductPage = async (networkHelper, page) => {
    await networkHelper.retryWithBackoff(async () => {
        // Look for different "Add to Cart" button selectors
        const addToCartSelectors = [
            "#add-to-cart-button",
            "#one-click-button",
            'input[name="submit.add-to-cart"]',
            'input[name="submit.buy-now"]',
        ];
        let addToCartButton = null;
        for (const selector of addToCartSelectors) {
            addToCartButton = await networkHelper
                .waitForSelector(page, selector, "visible", 2000)
                .catch(() => null);
            if (addToCartButton)
                break;
        }
        if (addToCartButton) {
            await addToCartButton.click();
        }
        else {
            console.log("Add to Cart button not found");
            throw new Error("Add to Cart button not found");
        }
    });
    await Promise.race([
        networkHelper
            .waitForSelector(page, "#attachSiNoCoverage", "visible", 5000)
            .then(async (button) => {
            if (button)
                await button.click();
        }),
        networkHelper
            .waitForSelector(page, "#siNoCoverage", "visible", 5000)
            .then(async (button) => {
            if (button)
                await button.click();
        }),
        networkHelper
            .waitForSelector(page, 'input[name="submit.addToCart"]', "visible", 5000)
            .then(async (button) => {
            if (button)
                await button.click();
        }),
        new Promise((resolve) => setTimeout(resolve, 5000)), // Timeout after 5 seconds if no elements are found
    ]);
    console.log("Item added to cart successfully");
};
/**
 * Submits the checkout process on the Amazon checkout page.
 *
 * @param networkHelper - Helper object for network-related operations
 * @param page - Playwright Page object that should be on the Amazon checkout page (https://www.amazon.com/gp/buy/spc/handlers/display.html)
 * @throws Error if unable to proceed with checkout or place the order
 */
const submitCheckoutOnCheckoutPage = async (networkHelper, page) => {
    await networkHelper.retryWithBackoff(async () => {
        await page.click('input[name="proceedToRetailCheckout"]');
        await networkHelper.waitForSelector(page, "#submitOrderButtonId", "visible");
    });
    await networkHelper.retryWithBackoff(async () => {
        await networkHelper.waitForNetworkIdle(page);
        await networkHelper.waitForSelector(page, 'input[name="placeYourOrder1"]:not([disabled])', "visible", 5000);
        await page.click('input[name="placeYourOrder1"]');
    });
};
const clickFirstVisibleItemOnSearchPage = async (networkHelper, page) => {
    await networkHelper.retryWithBackoff(async () => {
        await networkHelper.waitForSelector(page, 'div[data-component-type="s-search-result"]', "visible", 10000);
        const items = await page.$$('div[data-component-type="s-search-result"]');
        for (const item of items) {
            const isVisible = await item.isVisible();
            if (isVisible) {
                const titleLink = await item.$("a.a-link-normal.s-underline-text.s-underline-link-text.s-link-style.a-text-normal");
                if (titleLink) {
                    await titleLink.scrollIntoViewIfNeeded();
                    await titleLink.click();
                    await networkHelper.waitForPageLoad(page);
                    console.log("Clicked on the first visible item");
                    return;
                }
            }
        }
        console.log("No visible items found");
    });
};
/**
 * Navigates to the checkout page from the current page.
 *
 * @param networkHelper - Helper object for network-related operations
 * @param page - Playwright Page object that should be on any Amazon page with access to the cart
 */
const navigateToCheckoutPage = async (networkHelper, page) => {
    await page.click("a#nav-cart");
    await networkHelper.waitForSelector(page, 'input[name="proceedToRetailCheckout"]', "visible");
};
/**
 * Navigates to the account page from the current page.
 *
 * @param networkHelper - Helper object for network-related operations
 * @param page - Playwright Page object that should be on any Amazon page with access to the account menu
 */
const navigateToAccountPage = async (networkHelper, page) => {
    await page.click("a#nav-link-accountList");
    await networkHelper.waitForSelector(page, 'h1:has-text("Your Account")', "visible");
};
/**
 * Navigates to the orders page from the current page.
 *
 * @param networkHelper - Helper object for network-related operations
 * @param page - Playwright Page object that should be on the Amazon account page or any page with access to the orders link
 */
const navigateToOrdersPage = async (networkHelper, page) => {
    const ordersLink = await page.locator('a:has-text("Your Orders")').first();
    if (await ordersLink.isVisible()) {
        await ordersLink.click();
    }
    else {
        // If not found on the main account page, try the alternative method
        await page.click("#nav-orders");
    }
    // Wait for the Orders page to load
    await networkHelper.waitForSelector(page, 'h1:has-text("Your Orders")', "visible", 5000);
};
async function extractOrdersInfo(networkHelper, page) {
    const orders = [];
    try {
        // Wait for the orders to load
        await networkHelper.waitForPageLoad(page);
        // Get all order elements
        const orderElements = await page.$$(".order-card");
        for (const orderElement of orderElements) {
            const order = await extractSingleOrderInfo(orderElement);
            orders.push(order);
        }
        return orders;
    }
    catch (error) {
        console.error("Error extracting orders info:", error);
        return [];
    }
}
async function extractSingleOrderInfo(orderElement) {
    console.log("Extracting order info...");
    const order = {
        productName: "",
        status: "",
        totalPrice: "",
        orderDate: "",
        shippedToName: "",
        shippedToAddress: "",
    };
    try {
        // Extract order date
        const dateElement = await orderElement.$(".a-column.a-span3 .a-size-base.a-color-secondary");
        order.orderDate = (await dateElement?.innerText()) || "N/A";
        // Extract total price
        const priceElement = await orderElement.$(".a-column.a-span2 .a-size-base.a-color-secondary");
        order.totalPrice = (await priceElement?.innerText()) || "N/A";
        // Extract shipping information
        const shippingElement = await orderElement.$(".yohtmlc-recipient .a-size-base");
        if (shippingElement) {
            order.shippedToName = (await shippingElement.innerText()) || "N/A";
        }
        // Extract shipping address from popover
        const addressPopover = await orderElement.$(".a-popover-preload");
        if (addressPopover) {
            const addressLines = await addressPopover.$$eval(".a-row", (rows) => rows.map((row) => row.textContent.trim()));
            order.shippedToAddress = addressLines.slice(1).join(", ") || "N/A";
        }
        // Extract product name
        const productNameElement = await orderElement.$(".yohtmlc-product-title");
        order.productName = (await productNameElement?.innerText()) || "N/A";
        // Extract status
        const statusElement = await orderElement.$(".delivery-box__primary-text");
        order.status = (await statusElement?.innerText()) || "N/A";
    }
    catch (error) {
        console.error("Error extracting single order info:", error);
    }
    return order;
}
var index$3 = {
    demoAddHeadphonesToCart,
    getAllOrders,
    searchItem,
    addItemToCartOnProductPage,
    submitCheckoutOnCheckoutPage,
};

/**
 * Sends a direct message to a specified recipient on Instagram.
 *
 * @param networkHelper - Helper object for network-related operations
 * @param recipient - The username of the message recipient - This user will be on the home page
 * @param message - The content of the message to be sent
 * @returns A function that takes a Playwright Page object and performs the message sending operation
 */
const sendMessage$1 = (networkHelper, recipient, message) => async (page) => {
    try {
        await closeNotificationModal(page, networkHelper);
        await navigateToDirectInbox(page, networkHelper);
        await selectRecipientOnDirectMessage(page, networkHelper, recipient);
        await sendMessageOnMessageModal(page, networkHelper, message);
        console.log("Message sent successfully");
        await networkHelper.takeScreenshot(page, "instagram", "message-sent");
    }
    catch (error) {
        console.error("An error occurred:", error);
        await networkHelper.takeScreenshot(page, "instagram", "error-state");
        throw error; // Re-throw the error for upstream handling
    }
    finally {
        await page.close();
    }
};
/**
 * Navigates to the Instagram Direct Inbox.
 *
 * @param page - Playwright Page object. This action should be able to run on any page
 * @param networkHelper - Helper object for network-related operations
 */
async function navigateToDirectInbox(page, networkHelper) {
    await networkHelper.retryWithBackoff(async () => {
        // Wait for the mail icon to be visible
        const mailIconSelector = 'a[href="/direct/inbox/"]';
        await networkHelper.waitForSelector(page, mailIconSelector, "visible", networkHelper.networkTimeout);
        // Click on the mail icon
        await page.click(mailIconSelector);
        // Wait for the inbox page to load
        await networkHelper.waitForPageLoad(page);
        await networkHelper.waitForNetworkIdle(page);
        // Verify that we're on the inbox page
        const inboxUrlPattern = /https:\/\/www\.instagram\.com\/direct\/inbox\//;
        await page.waitForURL(inboxUrlPattern, {
            timeout: networkHelper.networkTimeout,
        });
        console.log("Navigated to Direct Inbox");
    });
}
/**
 * Handles the notification modal if it appears.
 *
 * @param page - Playwright Page object. This action should be able to run on any page
 * @param networkHelper - Helper object for network-related operations
 */
async function closeNotificationModal(page, networkHelper) {
    const modalSelector = 'div[role="dialog"]';
    const notNowButton = 'button:has-text("Not Now")';
    const modalVisible = await page.isVisible(modalSelector, {
        timeout: networkHelper.networkTimeout,
    });
    if (modalVisible) {
        await page.click(notNowButton);
        console.log("Clicked 'Not Now' on notification modal");
        await networkHelper.waitForNetworkIdle(page);
    }
}
/**
 * Opens up a new message modal and selects a recipient.
 *
 * @param page - Playwright Page object. The page should be on the Direct Inbox page
 * @param networkHelper - Helper object for network-related operations
 * @param recipient - The username of the message recipient
 */
async function selectRecipientOnDirectMessage(page, networkHelper, recipient) {
    await networkHelper.retryWithBackoff(async () => {
        // Click on the "New message" SVG button
        const newMessageButtonSelector = 'svg[aria-label="New message"]';
        await networkHelper.waitForSelector(page, newMessageButtonSelector, "visible", networkHelper.networkTimeout);
        await page.click(newMessageButtonSelector);
        console.log("Clicked on 'New message' button");
        // Wait for the recipient search modal to appear
        const searchModalSelector = 'div[role="dialog"]';
        await networkHelper.waitForSelector(page, searchModalSelector, "visible", networkHelper.networkTimeout);
        console.log("Recipient search modal appeared");
        // Wait for and click on the search input
        const searchInput = await networkHelper.waitForSelector(page, 'input[placeholder="Search..."]', "visible", 5000);
        if (!searchInput) {
            throw new Error("Search input for finding a user on Instagram's receipt messenging modal not found");
        }
        await searchInput.click();
        await searchInput.fill(recipient);
        await networkHelper.waitForNetworkIdle(page);
        // Wait for and click on the recipient
        const combinedSelector = `div[role="button"]:has-text("${recipient}") input[type="checkbox"]`;
        const checkbox = await networkHelper.waitForSelector(page, combinedSelector, "visible", 5000);
        if (!checkbox) {
            throw new Error(`Checkbox for recipient "${recipient}" not found`);
        }
        await checkbox.click();
        await networkHelper.waitForNetworkIdle(page);
        // Wait for and click the "Chat" button
        const chatButton = await networkHelper.waitForSelector(page, 'div[role="button"]:has-text("Chat")', "visible", 5000);
        if (!chatButton) {
            throw new Error("Chat button to select recipient not found");
        }
        await chatButton.click();
        await networkHelper.waitForNetworkIdle(page);
        console.log(`Selected recipient: ${recipient}`);
    });
}
/**
 * Sends a message to the selected recipient.
 *
 * @param page - Playwright Page object. This assumes that the page is on the direct message inbox page with the message modal open.
 * @param networkHelper - Helper object for network-related operations
 * @param message - The content of the message to be sent
 */
async function sendMessageOnMessageModal(page, networkHelper, message) {
    await networkHelper.retryWithBackoff(async () => {
        const messageInputSelector = 'div[aria-label="Message"] p';
        await networkHelper.waitForSelector(page, messageInputSelector, "visible", networkHelper.networkTimeout);
        // Type the message
        await page.fill(messageInputSelector, message);
        console.log("Message typed");
        // Locate and click the "Send" button
        const sendButtonSelector = 'div[role="button"]:has-text("Send")';
        await networkHelper.waitForSelector(page, sendButtonSelector, "visible", networkHelper.networkTimeout);
        await page.click(sendButtonSelector);
        console.log("Send button clicked");
        // Wait for the message to be sent
        await waitForMessageSent(page, networkHelper);
    });
}
async function waitForMessageSent(page, networkHelper) {
    await networkHelper.retryWithBackoff(async () => {
        // Wait for the "Seen" indicator to appear or for the message to be marked as sent
        const sentIndicatorSelector = 'span:has-text("Seen"), span:has-text("Sent")';
        await networkHelper.waitForSelector(page, sentIndicatorSelector, "visible", networkHelper.networkTimeout);
        console.log("Message sent successfully");
    });
}
var index$2 = {
    sendMessage: sendMessage$1,
    navigateToDirectInbox,
    closeNotificationModal,
    selectRecipientOnDirectMessage,
    sendMessageOnMessageModal,
};

/**
 * Retrieves the user's IP address and associated location data.
 *
 * This function navigates to a specific URL that returns JSON data containing
 * information about the user's IP address and geographical location. It then
 * parses this data and returns it as a LocationData object.
 *
 * @param page - The Playwright Page object to use for navigation
 * @returns A Promise that resolves to a LocationData object containing the IP and location information
 * @throws Will throw an error if the page doesn't contain any text or if the JSON parsing fails
 */
const runGetUserIpAddress = async (page) => {
    // Navigate to the IP address lookup service
    await page.goto("https://lumtest.com/myip.json");
    // Wait for the page to finish loading
    await page.mainFrame().waitForLoadState();
    // Extract the text content from the page body
    const text = await page.textContent("body");
    // Check if text content was successfully retrieved
    if (!text) {
        throw new Error("No text found on page");
    }
    // Parse the JSON text and return the resulting object
    return JSON.parse(text);
};
var index$1 = { runGetUserIpAddress };

/**
 * LinkedIn Automation Tools
 *
 * This module provides a set of functions to automate various LinkedIn tasks using Playwright.
 * These tools can be used to create posts, manage connections, send messages, and more.
 */
const NETWORK_TIMEOUT = 5000;
/**
 * Creates a LinkedIn post. Your page must be logged in and must be on the LinkedIn home page to create a post
 * @param networkHelper - Helper object for network-related operations
 * @param postContent
 * @returns
 */
const createPost = (networkHelper, postContent) => async (page) => {
    await networkHelper.waitForNetworkIdle(page);
    await clickOnPostModal(networkHelper, page);
    await writePostContent(networkHelper, postContent, page);
    await clickPostButton(networkHelper, page);
};
/**
 * Gets the LinkedIn connections of the currently logged in user
 * @param networkHelper - Helper object for network-related operations
 * @returns
 */
const getConnections = (networkHelper) => async (page) => {
    await navigateToProfile(networkHelper, page);
    await navigateToConnections(networkHelper, page);
    return await readContactsFromConnectionPage(networkHelper, page);
};
/**
 * Follows a LinkedIn company page. You must be on the LinkedIn home page to follow a company page
 * @param networkHelper - Helper object for network-related operations
 * @param companyName - The name of the company to follow
 * @returns
 */
const followCompanyPage = (networkHelper, companyName) => async (page) => {
    try {
        await searchOnHomePage(page, networkHelper, companyName);
        await clickFirstResultOnSearchPage("Companies", page, networkHelper);
        await networkHelper.waitForNetworkIdle(page);
        return await followCompanyOnCompanyPage(page, networkHelper, companyName);
    }
    catch (error) {
        console.error(`An error occurred: ${error}`);
        await networkHelper.takeScreenshot(page, "linkedin", `error-${companyName}`);
        return { type: "Error" };
    }
};
/**
 * Sends a LinkedIn message to a recipient. Your page must be logged in and must be on the recipient's profile page to send a message
 * @param networkHelper - Helper object for network-related operations
 * @param recipient - The name of the recipient
 * @param message - The message to send
 * @returns
 */
const sendMessage = (networkHelper, recipient, message) => async (page) => {
    await searchOnHomePage(page, networkHelper, recipient);
    await clickFirstResultOnSearchPage("People", page, networkHelper);
    await sendMessageOnProfilePage(networkHelper, message, page);
};
/**
 * Gets the general information and contact info of a LinkedIn user. Your page must be logged in and must be on the user's profile page to get the user info
 * @param networkHelper - Helper object for network-related operations
 * @param personName - The name of the person to get info for
 * @returns
 */
const getUserInfo = (networkHelper, personName) => async (page) => {
    try {
        await searchOnHomePage(page, networkHelper, personName);
        await clickFirstResultOnSearchPage("People", page, networkHelper);
        // Gets the general info of a user
        const generalInfo = await readProfileIntroOnPersonPage(page, networkHelper);
        // Clicks on the contact info modal and reads the contact info
        const contactInfo = await withContactInfoModal(page, networkHelper, readContactInfoOnContactModal);
        return {
            ...generalInfo,
            contactInfo,
        };
    }
    catch (error) {
        console.error(`An error occurred: ${error}`);
        await networkHelper.takeScreenshot(page, "linkedin", `error-${personName}`);
        throw new Error(`Cannot get user info for ${personName}`);
    }
};
/**
 * Sends a LinkedIn connection request to a person. This would only work if you are not connected with the person and that person is a 2nd degree connection
 * @param networkHelper - Helper object for network-related operations
 * @param personName - The name of the person to send a connection request to
 * @param message - The message to send with the connection request
 * @returns
 */
const sendConnectionRequest = (networkHelper, personName, message) => async (page) => {
    try {
        await searchOnHomePage(page, networkHelper, personName);
        await clickFirstResultOnSearchPage("People", page, networkHelper);
        await clickConnectButtonOnPersonPage(page, networkHelper);
        await fulfillConnectionRequestOnConnectionModal(page, networkHelper, personName, message);
    }
    catch (error) {
        console.error(`An error occurred: ${error}`);
        await networkHelper.takeScreenshot(page, "linkedin", `error-${personName}`);
        throw new Error(`Cannot get user info for ${personName}`);
    }
};
// close any existing message overlays.
async function closeMessageOverlay(page) {
    try {
        const closeButton = await page.$('svg[data-test-icon="close-small"]');
        if (closeButton) {
            await closeButton.click();
            console.log("Message overlay closed successfully.");
            return true;
        }
        else {
            console.log("Close button not found. No existing messages to close.");
            return false;
        }
    }
    catch (error) {
        console.error("Error while trying to close message overlay:", error);
        return false;
    }
}
/**
 * Sends a LinkedIn message to a person. Your page must be logged in and must be on the recipient's profile page to send a message. That person must be a 1st degree connection to the delegated user
 * @param networkHelper - Helper object for network-related operations
 * @param message - The message to send
 * @param page - Playwright Page object. The page must be on the recipient's profile page
 */
const sendMessageOnProfilePage = async (networkHelper, message, page) => {
    try {
        while (await closeMessageOverlay(page)) {
            // Continue closing overlays until no more are found
        }
        // Wait for and click the "Message" button
        const messageButton = await page.waitForSelector('button.pvs-profile-actions__action:has-text("Message")');
        await messageButton.click();
        // Wait for the message modal to appear
        await page.waitForSelector("div.msg-form__contenteditable");
        // Type the message
        await page.fill("div.msg-form__contenteditable", message);
        await networkHelper.waitForNetworkIdle(page);
        // Wait for and click the Send button using the more specific selector
        await networkHelper.retryWithBackoff(async () => {
            await networkHelper.waitForSelector(page, 'button:has-text("Send")');
            await page.click('button:has-text("Send")');
        });
        console.log("Waiting for message send confirmation...");
        await Promise.race([
            networkHelper.waitForNetworkIdle(page),
            page.waitForSelector('[aria-label="Message sent"]', {
                state: "visible",
                timeout: NETWORK_TIMEOUT,
            }),
            networkHelper.waitForPageLoad(page),
        ])
            .then(() => console.log("Message send confirmation received."))
            .catch(() => console.log("Message send confirmation timeout, but proceeding."));
    }
    catch (error) {
        console.error("Error sending message:", error);
    }
};
/**
 * Clicks on the first result of a search page based on the search query type. Your page must be on the search page to click on the first result
 * @param type - The type of search query. Can be "People" or "Companies"
 * @param page - Playwright Page object. The page must be on the search page
 * @param networkHelper - Helper object for network-related operations
 */
async function clickFirstResultOnSearchPage(type, page, networkHelper) {
    await networkHelper.retryWithBackoff(async () => {
        await networkHelper.waitForNetworkIdle(page);
        // Wait for and click the "People" tab
        const desiredTab = await page.waitForSelector(`button.search-reusables__filter-pill-button:has-text("${type}")`);
        await desiredTab.click();
        // Wait for the search results to update after clicking the tab
        await networkHelper.waitForNetworkIdle(page);
        // Wait for the search results container to load
        await page.waitForSelector("ul.reusable-search__entity-result-list");
        // Find the first link of the category
        const firstLink = await page
            .locator("li.reusable-search__result-container a.app-aware-link")
            .first();
        // Check if the link exists
        if ((await firstLink.count()) === 0) {
            throw new Error("No person result found");
        }
        // Click on the first link of the category
        await firstLink.click();
    });
    await networkHelper.waitForPageLoad(page);
}
/**
 * Writes a search query  on LinkedIn. You must be on the LinkedIn home page to search
 * @param page - Playwright Page object. The page must be on the LinkedIn home page
 * @param networkHelper - Helper object for network-related operations
 * @param query Query to search for
 */
async function searchOnHomePage(page, networkHelper, query) {
    console.log(`Searching for ${query}`);
    await networkHelper.retryWithBackoff(async () => {
        await page.click('[placeholder="Search"]');
        await page.fill('[placeholder="Search"]', query);
        await page.press('[placeholder="Search"]', "Enter");
    });
    await networkHelper.waitForPageLoad(page);
}
const clickConnectButtonOnPersonPage = async (page, networkHelper) => {
    await networkHelper.waitForPageLoad(page);
    console.log("Trying to find Connect Button");
    await page.click('button.pvs-profile-actions__action.artdeco-button[aria-label^="Invite"][aria-label$="to connect"]');
    console.log("Clicked button");
};
const fulfillConnectionRequestOnConnectionModal = async (page, networkHelper, personName, message) => {
    console.log("Connection modal open");
    await networkHelper.waitForNetworkIdle(page);
    console.log("Trying to find add button");
    const addNoteButton = await page
        .locator('button:has-text("Add a note")')
        .first();
    const sendButton = await page.locator('button:has-text("Send")').first();
    if (addNoteButton) {
        await addNoteButton.click();
        console.log("Clicked on add button");
        await page.fill('textarea[name="message"]', message ||
            "Hi, I'd like to connect with you on LinkedIn. I used the Anon SDK to help me do this");
        await page.click('button:has-text("Send")');
        await Promise.race([
            networkHelper.waitForNetworkIdle(page),
            networkHelper.waitForSelector(page, ".artdeco-modal-overlay", "hidden"),
            networkHelper.waitForPageLoad(page),
        ]);
    }
    else if (sendButton) {
        await Promise.race([
            networkHelper.waitForNetworkIdle(page),
            networkHelper.waitForSelector(page, ".artdeco-modal-overlay", "hidden"),
            networkHelper.waitForPageLoad(page),
        ]);
    }
    else {
        console.log(`Failed to send connection request to ${personName}`);
        await networkHelper.takeScreenshot(page, "linkedin", `failed-connect-${personName}`);
        throw new Error("Failed to Send Request");
    }
    console.log(`Successfully sent connection request to ${personName}`);
    await networkHelper.takeScreenshot(page, "linkedin", `connected-${personName}`);
};
/**
 * Reads the profile intro of a LinkedIn user. The user must be on a profile page of a person to read the profile intro
 * @param page - Playwright Page object
 * @param networkHelper - Helper object for network-related operations
 * @returns
 */
async function readProfileIntroOnPersonPage(page, networkHelper) {
    return await networkHelper.retryWithBackoff(async () => {
        await networkHelper.waitForNetworkIdle(page);
        console.log("Extracting Name");
        const nameElement = page.locator(".text-heading-xlarge");
        const name = await nameElement
            .textContent()
            .then((text) => (text ? text.replace("'s Profile", "").trim() : null));
        console.log("Extract Current Position");
        const positionElement = page.locator(".text-body-medium");
        const currentPosition = await positionElement
            .textContent()
            .then((text) => (text ? text.trim() : null));
        await networkHelper.waitForPageLoad(page);
        return {
            name,
            currentPosition,
        };
    });
}
/**
 * Reads the contact info of a LinkedIn user. This assumes that the user is on the contact info modal of a person
 * @param page - Playwright Page object. The page must be on the contact info modal of a person
 * @param networkHelper - Helper object for network-related operations
 * @returns
 */
async function readContactInfoOnContactModal(page, networkHelper) {
    return await networkHelper.retryWithBackoff(async () => {
        await networkHelper.waitForNetworkIdle(page);
        console.log("Waiting for modal to load");
        // Wait for the modal to load
        await page.waitForSelector("#pv-contact-info");
        // Extract contact info
        const contactInfo = {};
        // LinkedIn profile URL
        console.log("Getting LinkedIn profile URL");
        const linkedInProfileElement = await page
            .locator('.pv-contact-info__contact-type:has(svg[data-test-icon="linkedin-bug-medium"]) a')
            .first();
        const linkedInProfile = await linkedInProfileElement.getAttribute("href");
        if (linkedInProfile) {
            contactInfo["LinkedIn"] = linkedInProfile;
        }
        // Email
        console.log("Extracting Email");
        const emailSection = page.locator('.pv-contact-info__contact-type:has(svg[data-test-icon="envelope-medium"])');
        const emailElements = emailSection.locator("a.link-without-visited-state");
        const emails = await emailElements.allTextContents();
        if (emails.length > 0) {
            contactInfo["email"] = emails.map((email) => email.trim());
        }
        // Phone
        console.log("Extracting Phone Number");
        const phoneSection = page.locator('.pv-contact-info__contact-type:has(svg[data-test-icon="phone-handset-medium"])');
        const phoneElements = phoneSection.locator(".t-14.t-black.t-normal");
        const phones = await phoneElements.allTextContents();
        if (phones.length > 0) {
            contactInfo["Phone"] = phones.map((phone) => phone.trim());
        }
        // Websites
        console.log("Extracting Websites");
        const websitesSection = await page.locator('.pv-contact-info__contact-type:has(svg[data-test-icon="link-medium"])');
        const websiteElements = await websitesSection.locator("li").all();
        const websites = await Promise.all(websiteElements.map(async (element) => {
            const url = await element.locator("a").getAttribute("href");
            const typeElement = await element.locator("span").first();
            const type = await typeElement.textContent();
            return {
                url: url || "",
                type: type ? type.replace(/[()]/g, "").trim() : "",
            };
        }));
        if (websites.length > 0) {
            contactInfo["Websites"] = websites;
        }
        await networkHelper.waitForPageLoad(page);
        return contactInfo;
    });
}
/**
 * Clicks on the connect button on a LinkedIn profile page and runs callback that is designed for that callback. The user must be on a profile page of a person to click the connect button.
 * @param page - The Playwright Page object. The page must be on the profile page of a person
 * @param networkHelper - Helper object for network-related operations
 * @param operation - callback function that is designed to run after the connect button is clicked
 * @returns
 */
async function withContactInfoModal(page, networkHelper, operation) {
    console.log("Opening Contact Info modal");
    const contactInfoButton = page.locator("a#top-card-text-details-contact-info");
    await contactInfoButton.click();
    console.log("Waiting for modal to load");
    await page.waitForSelector("#pv-contact-info");
    try {
        // Perform the operation passed as a parameter
        const result = await operation(page, networkHelper);
        return result;
    }
    finally {
        console.log("Closing contact info modal");
        await networkHelper.retryWithBackoff(async () => {
            const closeButton = page.locator('button[aria-label="Dismiss"]').first();
            await closeButton.click();
            // Wait for the modal to disappear
            await page.waitForSelector("#pv-contact-info", { state: "detached" });
        });
    }
}
/**
 * Follows a LinkedIn company page. You must be on the LinkedIn company page to follow a company page
 * @param page - Playwright Page object. The page must be on the company page
 * @param networkHelper - Helper object for network-related operations
 * @param companyName - The name of the company to follow
 * @returns
 */
async function followCompanyOnCompanyPage(page, networkHelper, companyName) {
    // Look for the Follow button
    const followButton = await page
        .locator('button:has-text("Follow"), button:has-text("+ Follow")')
        .first();
    if (!followButton) {
        console.log("Follow button not found" + companyName ? ` for ${companyName}` : "");
        await networkHelper.takeScreenshot(page, "linkedin", "no-follow-button" + (companyName ? `-${companyName}` : ""));
        return { type: "Error", description: "Follow Button Not Found" };
    }
    const followButtonText = await followButton.textContent();
    if (followButtonText &&
        (followButtonText.trim() === "Follow" ||
            followButtonText.trim() === "+ Follow")) {
        await networkHelper.retryWithBackoff(async () => {
            await followButton.click();
        });
        await networkHelper.waitForNetworkIdle(page);
        console.log(`Successfully followed ${companyName}`);
        await networkHelper.takeScreenshot(page, "linkedin", `followed-${companyName}`);
        return { type: "Success" };
    }
    else {
        console.log(`Already following ${companyName}`);
        await networkHelper.takeScreenshot(page, "linkedin", `already-following-${companyName}`);
        return { type: "No Effect" };
    }
}
/**
 * Opens the post creation modal on LinkedIn.
 * @param networkHelper - Helper object for network-related operations
 * @param page - Playwright Page object. The page must be on the LinkedIn home page
 * @throws Error if unable to open the post creation modal
 */
const clickOnPostModal = async (networkHelper, page) => {
    console.log("Locating 'Start a post' button...");
    await networkHelper.retryWithBackoff(async () => {
        // Find the "Start a post" button
        const startPostButton = page.getByRole("button", {
            name: "Start a post",
        });
        // Wait for the button to be visible
        await startPostButton.waitFor({
            state: "visible",
            timeout: NETWORK_TIMEOUT,
        });
        console.log("'Start a post' button located and visible.");
    });
    // Take a screenshot before clicking the button
    await networkHelper.takeScreenshot(page, "linkedin", "1-before-clicking-start-post");
    console.log("Clicking 'Start a post' button...");
    await networkHelper.retryWithBackoff(async () => {
        // Click the "Start a post" button
        await page.getByRole("button", { name: "Start a post" }).click();
        // Wait for the page to load after clicking
        await networkHelper.waitForPageLoad(page);
        console.log("'Start a post' button clicked successfully.");
    });
    // Take a screenshot after clicking the button
    await networkHelper.takeScreenshot(page, "linkedin", "2-after-clicking-start-post");
    console.log("Waiting for post creation modal...");
    await networkHelper.retryWithBackoff(async () => {
        // Wait for the post creation modal to appear
        await page.waitForSelector('div[role="dialog"]', {
            state: "visible",
            timeout: NETWORK_TIMEOUT,
        });
        // Wait for all network activity to settle
        await networkHelper.waitForNetworkIdle(page);
        console.log("Post creation modal is visible.");
    });
    // Take a screenshot of the post creation modal
    await networkHelper.takeScreenshot(page, "linkedin", "3-post-creation-modal");
};
/**
 * Writes the content of a post in the LinkedIn post creation modal.
 * @param networkHelper - Helper object for network-related operations
 * @param postContent - The content to be written in the post
 * @param page - Playwright Page object. The page must be on the LinkedIn post creation modal
 * @throws Error if unable to write the post content
 */
const writePostContent = async (networkHelper, postContent, page) => {
    console.log("Locating and interacting with text editor...");
    await networkHelper.retryWithBackoff(async () => {
        // Find the text editor in the post creation modal
        const textEditor = page.getByRole("textbox", {
            name: "Text editor for creating",
        });
        // Wait for the text editor to be visible
        await textEditor.waitFor({ state: "visible", timeout: NETWORK_TIMEOUT });
        // Fill the text editor with the post content
        await textEditor.fill(postContent);
        // Wait for all network activity to settle
        await networkHelper.waitForNetworkIdle(page);
        console.log("Post content written successfully.");
    });
    // Take a screenshot after writing the post content
    await networkHelper.takeScreenshot(page, "linkedin", "4-after-writing-post");
};
/**
 * Clicks the 'Post' button to publish the LinkedIn post.
 * @param networkHelper - Helper object for network-related operations
 * @param page - Playwright Page object. The page must be on the LinkedIn post creation modal and the text must be filled
 * @throws Error if unable to click the 'Post' button or confirm post creation
 */
const clickPostButton = async (networkHelper, page) => {
    console.log("Locating and clicking 'Post' button...");
    await networkHelper.retryWithBackoff(async () => {
        // Find the 'Post' button
        const postButton = page.getByRole("button", {
            name: "Post",
            exact: true,
        });
        // Wait for the 'Post' button to be visible
        await postButton.waitFor({ state: "visible", timeout: NETWORK_TIMEOUT });
        // Click the 'Post' button
        await postButton.click();
        console.log("'Post' button clicked successfully.");
    });
    // Take a screenshot after clicking the 'Post' button
    await networkHelper.takeScreenshot(page, "linkedin", "5-after-clicking-post");
    console.log("Waiting for post confirmation...");
    // Wait for either network idle, post success message, or page load
    await Promise.race([
        networkHelper.waitForNetworkIdle(page),
        page.waitForSelector('[aria-label="Post successful"]', {
            state: "visible",
            timeout: NETWORK_TIMEOUT,
        }),
        networkHelper.waitForPageLoad(page),
    ])
        .then(() => console.log("Post confirmation received."))
        .catch(() => console.log("Post confirmation timeout, but proceeding."));
    // Take a final screenshot after posting
    await networkHelper.takeScreenshot(page, "linkedin", "6-after-posting");
};
/**
 * Navigates to the user's own LinkedIn profile page.
 * @param networkHelper - Helper object for network-related operations
 * @param page - Playwright Page object. The page must be on the LinkedIn home page
 * @throws Error if unable to navigate to the profile page
 */
const navigateToProfile = async (networkHelper, page) => {
    // Wait for all network activity to settle
    await networkHelper.waitForNetworkIdle(page);
    await networkHelper.retryWithBackoff(async () => {
        // Click on the user's profile photo in the navigation bar
        await page.click(".global-nav__me-photo");
    });
    await networkHelper.retryWithBackoff(async () => {
        // Click on the "View Profile" link in the dropdown menu
        await page.click('//a[text()="View Profile"]');
    });
    // Wait for the profile page to load
    await networkHelper.waitForPageLoad(page);
};
/**
 * Reads and extracts information about the user's LinkedIn connections from the connections page.
 * @param networkHelper - Helper object for network-related operations
 * @param page - Playwright Page object. The page must be on the LinkedIn connections page
 * @returns An array of LinkedInConnection objects containing connection information
 * @throws Error if unable to read connection information
 */
const readContactsFromConnectionPage = async (networkHelper, page) => {
    // Wait for all network activity to settle
    await networkHelper.waitForNetworkIdle(page);
    // Extract connection information from the page
    return await page.$$eval(".mn-connection-card", (cards) => cards.map((card) => ({
        name: card.querySelector(".mn-connection-card__name")?.textContent?.trim() ||
            "",
        title: card
            .querySelector(".mn-connection-card__occupation")
            ?.textContent?.trim() || "",
        profileUrl: card.querySelector(".mn-connection-card__link")?.href || "",
    })));
};
/**
 * Navigates to the user's LinkedIn connections page.
 * @param networkHelper - Helper object for network-related operations
 * @param page - Playwright Page object. The page must be on a profile page
 * @throws Error if unable to navigate to the connections page
 */
const navigateToConnections = async (networkHelper, page) => {
    console.log("Trying to get connections");
    await networkHelper.retryWithBackoff(async () => {
        // Wait for the connections link to be visible
        await networkHelper.waitForSelector(page, 'a[href*="/mynetwork/invite-connect/connections/"]', "visible");
        // Find the connections link
        const connectionsLink = await page.waitForSelector('a[href*="/mynetwork/invite-connect/connections/"]', { state: "visible" });
        // Click on the connections link
        await connectionsLink.click();
        console.log("Clicked on connections link");
        // Wait for the connections page to load
        await networkHelper.waitForPageLoad(page);
    });
    // Wait again for the page to fully load (ensuring all dynamic content is loaded)
    await networkHelper.waitForPageLoad(page);
};
var index = {
    createPost,
    getConnections,
    followCompanyPage,
    sendMessage,
    getUserInfo,
    sendConnectionRequest,
    sendMessageOnProfilePage,
    clickFirstResultOnSearchPage,
    searchOnHomePage,
    clickConnectButtonOnPersonPage,
    fulfillConnectionRequestOnConnectionModal,
    readProfileIntroOnPersonPage,
    readContactInfoOnContactModal,
    readContactsFromConnectionPage,
    withContactInfoModal,
    followCompanyOnCompanyPage,
    clickOnPostModal,
    writePostContent,
    clickPostButton,
    navigateToProfile,
    navigateToConnections,
};

class NetworkHelper {
    networkTimeout;
    maxRetries;
    constructor(networkTimeout = 30000, maxRetries = 3) {
        this.networkTimeout = networkTimeout;
        this.maxRetries = maxRetries;
    }
    async waitForNetworkIdle(page, timeout = this.networkTimeout) {
        console.log("Waiting for network to become idle...");
        try {
            await page.waitForLoadState("networkidle", { timeout });
            console.log("Network is idle.");
        }
        catch (error) {
            console.warn("Network did not reach idle state within timeout, continuing...");
        }
    }
    async waitForPageLoad(page) {
        console.log("Waiting for page to load...");
        try {
            await page.waitForLoadState("load");
            console.log("Page loaded.");
        }
        catch (error) {
            console.warn("Page did not load within timeout, continuing...");
        }
    }
    async waitForSelector(page, selector, state, timeout = this.networkTimeout) {
        console.log(`Waiting for selector: ${selector}...`);
        try {
            const result = await page.waitForSelector(selector, { state, timeout });
            console.log(`Selector found: ${selector}`);
            return result;
        }
        catch (error) {
            console.warn(`Selector not found: ${selector}`);
        }
    }
    async retryWithBackoff(action, maxRetries = this.maxRetries, baseDelay = 1000) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await action();
            }
            catch (error) {
                if (attempt === maxRetries)
                    throw error;
                const delay = baseDelay * Math.pow(2, attempt - 1);
                console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
        }
        throw new Error("Max retries reached");
    }
    async takeScreenshot(page, prefix, name) {
        await page.screenshot({
            path: `screenshot-${prefix}-${name}-${Date.now()}.png`,
            fullPage: true,
        });
        console.log(`Screenshot taken: ${name}`);
    }
}

exports.Amazon = index$3;
exports.Instagram = index$2;
exports.IpAddressUtil = index$1;
exports.LinkedIn = index;
exports.NetworkHelper = NetworkHelper;
