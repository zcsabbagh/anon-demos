'use strict';

var playwright = require('playwright');
var fernSdk = require('@anon/fern-sdk');

class AnonRuntime {
    apiKey;
    environment;
    client;
    constructor({ apiKey, environment = "sandbox", }) {
        this.apiKey = apiKey;
        this.environment = environment;
        const protocol = environment === "local" ? "http" : "https";
        const baseUrl = `${protocol}://svc.${environment}.anon.com`;
        this.client = new fernSdk.AnonApiClient({
            token: apiKey,
            anonSdkClientId: "",
            environment: baseUrl,
        });
    }
    /**
     * Run an `action` for a given user with `appUserId` connected to
     * `apps`. Returns a `liveStreamingUrl` where the action can be observed
     * while in progress, and a `result` that is returned by the given
     * `action`. You must navigate to the page on which you'd like to to perform
     * the action using `page.goto`.
     *
     * See the {@link https://docs.anon.com/reference/sdk/sdk-typescript-ref|docs} for more examples.
     *
     * @example
     * const anon = new AnonRuntime({ apiKey: "your api key here" });
     *
     * // The username of the user whose account to use
     * const appUserId = "myProduct-user";
     * // The app sessions to inject
     * const apps = ["linkedin"];
     * // The action to be performed
     * const action = async (page) => {
     *   await page.goto("https://linkedin.com");
     *   await LinkedIn.createPost(page, {
     *     title: "I love Anon",
     *     content: "They make automating actions so easy! Check out docs.anon.com to learn more."
     *   });
     * }
     *
     * const { result, liveStreamingUrl } = await anon.run({
     *   appUserId,
     *   apps: ["linkedin"],
     *   action
     * });
     *
     * // You can use the liveStreamingUrl to watch your action be performed.
     *
     * // Await the successful completion of the action
     * await result;
     */
    async run(input) {
        const startSdkTime = Date.now();
        const { appUserId, apps } = input;
        const runtimeStartActivity = await this.client.activity.createEvent({
            activityType: "runtime",
            data: { type: "runtimeStart" },
            datetime: Date.now(),
            userId: input.appUserId,
            browserType: "managed",
        });
        if (runtimeStartActivity.type === "error") {
            throw new Error(`cannot create activity log: ${runtimeStartActivity.error}`);
        }
        const groupId = runtimeStartActivity.groupId;
        // analytics
        const userMetadata = {
            anonSessionId: "UNKNOWN", // TODO is this important
            externalUserId: appUserId,
        };
        const app = apps !== "all" ? apps.join(",") : "all";
        const environment = this.environment;
        const partialBrowserConfig = {
            browserType: "managed",
            activityGroupId: groupId,
            proxy: { isAnonProxyEnabled: "proxy" in input ? false : true },
        };
        try {
            const { cdpUrl, liveStreamingUrl } = await this.client.run.createCdpUrl({
                appUserId,
                apps,
                activityGroupId: groupId,
                ...("cdpUrl" in input ? { cdpUrl: input.cdpUrl } : {}),
                ...("proxy" in input ? { proxy: input.proxy } : {}),
            });
            const browserOptions = {
                ...("logger" in input ? { logger: input.logger } : {}),
            };
            const browser = await playwright.chromium.connectOverCDP(cdpUrl, browserOptions);
            const browserConfig = {
                ...partialBrowserConfig,
                browserbase: {
                    sessionId: "UNKNOWN", // TODO is this important,
                    sessionUrl: cdpUrl,
                },
            };
            // Getting the default context to ensure the sessions are recorded.
            const context = browser.contexts()[0];
            const page = context.pages()[0];
            const startRuntimeExecutionTime = Date.now();
            const onActionSuccess = async (_) => {
                await this.client.activity.createEventWithGroupId(groupId, {
                    activityType: "runtime",
                    data: { type: "runtimeExecutionSuccess" },
                    datetime: Date.now(),
                    userId: input.appUserId,
                    browserType: "managed",
                });
                await this.client.runtimeLog.recordLog({
                    app,
                    environment,
                    browserConfig,
                    userMetadata,
                    runtimeResult: {
                        type: "success",
                        startSdkTime,
                        startRuntimeExecutionTime,
                        endRuntimeExecutionTime: Date.now(),
                    },
                });
            };
            const onActionFailure = async (e) => {
                await this.client.activity.createEventWithGroupId(groupId, {
                    activityType: "runtime",
                    data: {
                        type: "runtimeExecutionError",
                        error: e instanceof Error ? e.toString() : "did not throw error",
                        errorStack: e instanceof Error && e.stack
                            ? e.stack
                            : "No stack trace available",
                    },
                    datetime: Date.now(),
                    userId: input.appUserId,
                    browserType: "managed",
                });
                await this.client.runtimeLog.recordLog({
                    app,
                    environment,
                    browserConfig,
                    userMetadata,
                    runtimeResult: {
                        type: "error",
                        classification: "runtimePlaywrightError",
                        error: e instanceof Error ? e.toString() : "did not throw error",
                        startSdkTime,
                        startRuntimeExecutionTime,
                        endRuntimeExecutionTime: Date.now(),
                    },
                });
            };
            await this.client.activity.createEventWithGroupId(groupId, {
                activityType: "runtime",
                data: { type: "runtimeExecutionStart" },
                datetime: Date.now(),
                userId: input.appUserId,
                browserType: "managed",
            });
            const runWithLogging = async (input) => {
                try {
                    const result = await input.action(page);
                    await onActionSuccess(result);
                    return result;
                }
                catch (e) {
                    await onActionFailure(e);
                    throw e;
                }
                finally {
                    await page.close();
                    await browser.close();
                }
            };
            const result = runWithLogging(input);
            return {
                result,
                ...(liveStreamingUrl ? { liveStreamingUrl } : {}),
            };
        }
        catch (e) {
            await this.client.runtimeLog.recordLog({
                app,
                environment,
                browserConfig: {
                    ...partialBrowserConfig,
                    browserbase: {
                        sessionId: "UNKNOWN", // TODO is this important
                    },
                },
                userMetadata,
                runtimeResult: {
                    type: "error",
                    classification: "other",
                    error: e instanceof Error ? e.toString() : "did not throw error",
                    startSdkTime,
                    endRuntimeExecutionTime: Date.now(),
                },
            });
            throw e;
        }
    }
    /** List all linked sessions for the app user with given `appUserId` */
    async listSessions({ appUserId }) {
        return await this.client.session.listSessions({ appUserId });
    }
    /** Get the session status for an app user and app integration. */
    async getSessionStatus({ appUserId, app, }) {
        return await this.client.session.getSessionStatus({ appUserId, app });
    }
}

exports.AnonRuntime = AnonRuntime;
