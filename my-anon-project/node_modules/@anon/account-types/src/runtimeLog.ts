import { z } from "zod";
import { TypedResponse } from "./typedResponse";

// TODO: put this API on it's own file.
const AnonEnvironmentSchema = z.enum([
  "local",
  "development",
  "staging",
  "sandbox",
  "prod",
]);
export type AnonEnvironment = z.infer<typeof AnonEnvironmentSchema>;

const LocalBrowserConfigSchema = z.object({
  browserType: z.literal("local"),
  isHeadless: z.boolean().optional(),
  proxy: z
    .object({
      isAnonProxyEnabled: z.boolean(),
    })
    .optional(),
});
export type LocalBrowserConfig = z.infer<typeof LocalBrowserConfigSchema>;

const BrowserbaseSessionSchema = z.object({
  sessionId: z.string(),
  sessionUrl: z.string().optional(),
});

export type BrowserbaseSession = z.infer<typeof BrowserbaseSessionSchema>;

const ManagedBrowserConfigSchema = z.object({
  browserType: z.literal("managed"),
  proxy: z
    .object({
      isAnonProxyEnabled: z.boolean(),
    })
    .optional(),
  browserbase: BrowserbaseSessionSchema.optional(),
});
export type ManagedBrowserConfig = z.infer<typeof ManagedBrowserConfigSchema>;

const RemoteBrowserConfigSchema = z.object({
  browserType: z.literal("remote"),
});
export type RemoteBrowserConfig = z.infer<typeof RemoteBrowserConfigSchema>;

const InferredRuntimeBrowserConfigSchema = z.object({
  browserType: z.literal("inferred"),
  proxy: z
    .object({
      ip: z.string().ip(),
      username: z.string().optional(),
    })
    .optional(),
  connectionUrl: z.string().optional(),
});

export type InferredRuntimeBrowserConfig = z.infer<
  typeof InferredRuntimeBrowserConfigSchema
>;

const BaseRuntimeResultSchema = z.object({
  type: z.enum(["success", "error"]),
  // Unix time in milliseconds
  startSdkTime: z.number(),
});

const SuccessRuntimeResultSchema = BaseRuntimeResultSchema.extend({
  type: z.literal("success"),
  // Unix time in milliseconds
  startRuntimeExecutionTime: z.number(),
  // Unix time in milliseconds
  endRuntimeExecutionTime: z.number(),
});

const FailedToInjectSchema = BaseRuntimeResultSchema.extend({
  type: z.literal("error"),
  classification: z.literal("failedToInjectSession"),
  error: z.string(),
});

const RuntimePlaywrightErrorSchema = FailedToInjectSchema.extend({
  type: z.literal("error"),
  classification: z.literal("runtimePlaywrightError"),
  // Unix time in milliseconds
  startRuntimeExecutionTime: z.number(),
  // Unix time in milliseconds
  endRuntimeExecutionTime: z.number(),
});

const OtherErrorSchema = FailedToInjectSchema.extend({
  type: z.literal("error"),
  classification: z.literal("other"),
  // Unix time in seconds
  startRuntimeExecutionTime: z.number().optional(),
  // Unix time in seconds
  endRuntimeExecutionTime: z.number().optional(),
});

const RuntimeResultSchema = z.union([
  SuccessRuntimeResultSchema,
  FailedToInjectSchema,
  RuntimePlaywrightErrorSchema,
  OtherErrorSchema,
]);

export type RuntimeResult = z.infer<typeof RuntimeResultSchema>;

const UserMetadataSchema = z.object({
  anonSessionId: z.string(),
  anonUserId: z.string(),
  externalUserId: z.string(),
  orgId: z.string(),
  orgName: z.string(),
  sdkClientId: z.string(),
  sdkClientName: z.string(),
  sessionCollectionTime: z.date().optional(),
});

export type UserMetadata = z.infer<typeof UserMetadataSchema>;

const makeRuntimeLogSchema = <
  UserMetadata extends z.ZodTypeAny,
  BrowserConfig extends z.ZodTypeAny,
>(
  userMetadataSchema: UserMetadata,
  browserConfigSchema: BrowserConfig,
) =>
  z.object({
    environment: AnonEnvironmentSchema,
    userMetadata: userMetadataSchema,
    browserConfig: browserConfigSchema,
    app: z.string(),
    runtimeResult: RuntimeResultSchema,
  });

const BrowserConfigSchema = z.discriminatedUnion("browserType", [
  ManagedBrowserConfigSchema,
  LocalBrowserConfigSchema,
  RemoteBrowserConfigSchema,
]);

const CreateUserMetadataSchema = z.object({
  anonSessionId: z.string(),
  externalUserId: z.string(),
});
export type CreateUserMetadata = z.infer<typeof CreateUserMetadataSchema>;

const RuntimeLogSchema = makeRuntimeLogSchema(
  UserMetadataSchema,
  BrowserConfigSchema,
);
export type RuntimeLog = z.infer<typeof RuntimeLogSchema>;

const BrowserConfigCreateRequestSchema = z.discriminatedUnion("browserType", [
  ManagedBrowserConfigSchema,
  LocalBrowserConfigSchema,
  RemoteBrowserConfigSchema,
  InferredRuntimeBrowserConfigSchema,
]);
/**
 * Schema to create a new runtime logs record. There are subtle difference in this creation payload over the
 * RuntimeLogSchema. Namely, it's meant to make creation easier and infer data for the RuntimeLog on th server side
 */
export const RuntimeLogCreateRequestSchema = makeRuntimeLogSchema(
  CreateUserMetadataSchema,
  BrowserConfigCreateRequestSchema,
);

export type RuntimeLogCreateRequest = z.infer<
  typeof RuntimeLogCreateRequestSchema
>;

export {
  AnonEnvironmentSchema,
  LocalBrowserConfigSchema,
  ManagedBrowserConfigSchema,
  RemoteBrowserConfigSchema,
  RuntimeResultSchema,
  UserMetadataSchema,
  RuntimeLogSchema,
};

export type RecordLogResponse = Response &
  TypedResponse<{
    message: string;
    recordedAt?: string;
  }>;
