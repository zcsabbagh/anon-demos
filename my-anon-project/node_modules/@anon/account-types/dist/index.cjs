'use strict';

var zod = require('zod');

const StorageTypeSchema = zod.z.enum(["local", "session", "cookie"]);
const BaseIndicatorSchema = zod.z.object({
    key: zod.z.string(),
});
const LocalOrSessionIndicatorSchema = BaseIndicatorSchema.merge(zod.z.object({
    storage: zod.z.enum(["local", "session"]),
}));
const CookieIndicatorSchema = BaseIndicatorSchema.merge(zod.z.object({
    storage: zod.z.literal("cookie"),
    domains: zod.z.array(zod.z.string()),
    validator: zod.z
        .object({
        kind: zod.z.literal("jwt_claim"),
        value: zod.z.string(),
    })
        .optional(),
}));
const SessionCompletionIndicatorSchema = LocalOrSessionIndicatorSchema.or(CookieIndicatorSchema);
// Defines the rule for matching the validation criteria.
exports.WebValidationMatchRule = void 0;
(function (WebValidationMatchRule) {
    WebValidationMatchRule["ALL"] = "ALL";
    WebValidationMatchRule["ANY"] = "ANY";
})(exports.WebValidationMatchRule || (exports.WebValidationMatchRule = {}));

const AppIntegrationConfigRegistry = {
    linkedin: {
        authUrl: "https://linkedin.com",
        displayName: "LinkedIn",
        iconUrl: "https://logo.clearbit.com/linkedin.com",
        completionIndicators: [
            {
                storage: "cookie",
                key: "li_at",
                domains: [".www.linkedin.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".linkedin.com",
            },
            {
                domain: ".www.linkedin.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://www.linkedin.com/mypreferences/d/categories/account",
                    criteria: [
                        {
                            selector: 'h2:has-text("General preferences")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    facebook: {
        authUrl: "https://facebook.com",
        displayName: "Facebook",
        iconUrl: "https://logo.clearbit.com/facebook.com",
        domCompletionIndicator: `//*[contains(@aria-label, 'Create story')]`,
        completionIndicators: [
            {
                storage: "cookie",
                key: "c_user",
                domains: [".facebook.com"],
            },
            {
                storage: "cookie",
                key: "sb",
                domains: [".facebook.com"],
            },
            {
                storage: "cookie",
                key: "xs",
                domains: [".facebook.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".facebook.com",
            },
            {
                domain: "www.facebook.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [],
        },
    },
    github: {
        authUrl: "https://github.com/login",
        displayName: "Github",
        iconUrl: "https://logo.clearbit.com/github.com",
        completionIndicators: [
            {
                storage: "cookie",
                key: "user_session",
                domains: ["github.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: "github.com",
            },
            {
                domain: ".github.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://github.com/settings/profile",
                    criteria: [
                        {
                            selector: 'h2:has-text("Public profile")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    instagram: {
        authUrl: "https://www.instagram.com/accounts/login/",
        displayName: "Instagram",
        iconUrl: "https://logo.clearbit.com/instagram.com",
        completionIndicators: [
            {
                storage: "cookie",
                key: "sessionid",
                domains: [".instagram.com"],
            },
            {
                storage: "cookie",
                key: "ig_did",
                domains: [".instagram.com", "www.instagram.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".instagram.com",
            },
            {
                domain: ".facebook.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [],
        },
    },
    uber: {
        authUrl: "https://m.uber.com/",
        displayName: "Uber",
        iconUrl: "https://logo.clearbit.com/uber.com",
        domCompletionIndicator: "//h1[text()='Get a ride']",
        completionIndicators: [
            {
                storage: "cookie",
                key: "jwt-session",
                domains: ["m.uber.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: "www.uber.com",
            },
            {
                domain: ".uber.com",
            },
            {
                domain: "m.uber.com",
            },
            {
                domain: "auth.uber.com",
            },
            {
                domain: ".auth.uber.com",
            },
            {
                domain: ".www.uber.com",
            },
            {
                domain: ".payments.uber.com",
            },
            {
                domain: "payments.uber.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://account.uber.com/",
                    criteria: [
                        {
                            selector: 'span:has-text("For Me")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    uber_eats: {
        experimental: true,
        authUrl: "https://www.ubereats.com/login-redirect",
        displayName: "Uber Eats",
        iconUrl: "https://logo.clearbit.com/ubereats.com",
        domCompletionIndicator: "//button[@aria-label='Carts']",
        completionIndicators: [
            {
                storage: "cookie",
                key: "jwt-session",
                domains: ["www.ubereats.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: "www.ubereats.com",
            },
            {
                domain: ".ubereats.com",
            },
            {
                domain: "ubereats.com",
            },
            {
                domain: "www.uber.com",
            },
            {
                domain: ".uber.com",
            },
            {
                domain: "m.uber.com",
            },
            {
                domain: "auth.uber.com",
            },
            {
                domain: ".auth.uber.com",
            },
            {
                domain: ".www.uber.com",
            },
            {
                domain: ".payments.uber.com",
            },
            {
                domain: "payments.uber.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://account.uber.com/",
                    criteria: [
                        {
                            selector: 'h2:has-text("Basic Info")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    delta: {
        authUrl: "https://www.delta.com/skymiles/login",
        displayName: "Delta Air Lines",
        iconUrl: "https://logo.clearbit.com/delta.com",
        completionIndicators: [
            {
                storage: "cookie",
                key: "isin",
                domains: [".delta.com", "www.delta.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".delta.com",
            },
            {
                domain: "www.delta.com",
            },
            {
                domain: "signin.delta.com",
            },
            {
                domain: ".dotomi.com",
            },
            {
                domain: ".adnxs.com",
            },
            {
                domain: ".demdex.net",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://www.delta.com/myprofile/personal-details",
                    criteria: [
                        {
                            selector: 'h3:has-text("Basic Info")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    united_airlines: {
        authUrl: "https://www.united.com/en/us/united-mileageplus-signin/",
        displayName: "United Airlines",
        iconUrl: "https://logo.clearbit.com/united.com",
        completionIndicators: [
            {
                storage: "cookie",
                key: "Session",
                domains: [".united.com", "www.united.com"],
            },
            {
                storage: "cookie",
                key: "User",
                domains: [".united.com", "www.united.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".united.com",
            },
            {
                domain: "www.united.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
            // {
            //note(boateng): Is the /en/us path too strict? Should atleast still work for usa customers
            //FIXME(boateng): United seems to be blocking when performing session validity checks, i.e injecting the session
            //   url: "https://www.united.com/en/us/myunited",
            //   criteria: [
            //     {
            //       selector: "text=/My United/",
            //       exists: true,
            //     },
            //   ],
            //   matchRule: WebValidationMatchRule.ANY,
            // },
            ],
        },
    },
    instacart: {
        displayName: "Instacart",
        iconUrl: "https://instacart.com/favicon.ico",
        authUrl: "https://www.instacart.com/login?next=%2Fstore",
        completionIndicators: [
            {
                storage: "cookie",
                key: "__Host-instacart_sid",
                domains: ["www.instacart.com", ".instacart.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".instacart.com",
            },
            {
                domain: "www.instacart.com",
            },
            {
                domain: ".www.instacart.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://www.instacart.com/store/account",
                    criteria: [
                        {
                            selector: "text=/Account information/",
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    resy: {
        displayName: "Resy",
        iconUrl: "https://resy.com/favicon.ico",
        authUrl: "https://resy.com/account/profile",
        domCompletionIndicator: "//div[contains(@class, 'logged-in')]",
        completionIndicators: [
            {
                storage: "cookie",
                key: "authToken",
                domains: ["resy.com", ".resy.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".resy.com",
            },
            {
                domain: "www.resy.com",
            },
            {
                domain: "resy.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://resy.com/account/profile",
                    criteria: [
                        {
                            selector: 'h2:has-text("Profile")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    netflix: {
        displayName: "Netflix",
        iconUrl: "https://netflix.com/favicon.ico",
        authUrl: "https://www.netflix.com/login",
        domCompletionIndicator: "//div[contains(@class, 'title-boxart')]",
        completionIndicators: [
            {
                storage: "cookie",
                key: "NetflixId",
                domains: ["netflix.com", ".netflix.com", "www.netflix.com"],
            },
            {
                storage: "cookie",
                key: "SecureNetflixId",
                domains: ["netflix.com", ".netflix.com", "www.netflix.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".netflix.com",
            },
            {
                domain: "www.netflix.com",
            },
            {
                domain: "netflix.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://www.netflix.com/account",
                    criteria: [
                        {
                            selector: 'h2:has-text("Profiles")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    amazon: {
        displayName: "Amazon",
        iconUrl: "https://amazon.com/favicon.ico",
        authUrl: "https://www.amazon.com/gp/sign-in.html",
        domCompletionIndicator: "//div[contains(@id, 'nav-global-location-slot')]",
        completionIndicators: [
            {
                storage: "cookie",
                key: "sess-at-main",
                domains: [".amazon.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".amazon.com",
            },
            {
                domain: "www.amazon.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://www.amazon.com/gp/your-account/order-history",
                    criteria: [
                        {
                            selector: 'h1:has-text("Your Orders")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    opentable: {
        displayName: "OpenTable",
        iconUrl: "https://opentable.com/favicon.ico",
        authUrl: "https://www.opentable.com/authenticate/start?isPopup=false",
        domCompletionIndicator: "//h2[text()='Points']",
        completionIndicators: [
            {
                storage: "cookie",
                key: "authCke",
                domains: [".opentable.com", "www.opentable.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".opentable.com",
            },
            {
                domain: "www.opentable.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://www.opentable.com/user/dining-dashboard",
                    criteria: [
                        {
                            selector: 'h2:has-text("Points")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    twitter: {
        authUrl: "https://twitter.com",
        displayName: "Twitter",
        iconUrl: "https://abs.twimg.com/favicons/twitter.3.ico",
        completionIndicators: [
            {
                storage: "cookie",
                key: "auth_token",
                domains: [".twitter.com", "www.twitter.com", ".x.com", "www.x.com"],
            },
            {
                storage: "cookie",
                key: "twid",
                domains: [".twitter.com", "www.twitter.com", ".x.com", "www.x.com"],
            },
        ],
        sessionExtractionDomains: [
            {
                domain: ".twitter.com",
            },
            {
                domain: ".x.com",
            },
        ],
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://x.com/settings/account",
                    criteria: [
                        {
                            selector: 'span:has-text("Account Information")',
                            exists: true,
                        },
                        {
                            selector: 'span:has-text("Your account")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
    },
    doordash: {
        authUrl: "https://www.doordash.com/orders/",
        displayName: "Doordash",
        iconUrl: "https://logo.clearbit.com/doordash.com",
        sessionExtractionDomains: [
            {
                domain: ".doordash.com",
            },
            {
                domain: "www.doordash.com",
            },
        ],
        domCompletionIndicator: "//span[text()='Orders']",
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://www.doordash.com/consumer/edit_profile/",
                    criteria: [
                        {
                            selector: 'h2:has-text("Profile")',
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
        completionIndicators: [
            {
                storage: "cookie",
                key: "ddweb_token",
                domains: [".doordash.com", "www.doordash.com"],
            },
            {
                storage: "cookie",
                key: "ddweb_session_id",
                domains: [".doordash.com", "www.doordash.com"],
            },
        ],
    },
    google: {
        experimental: true,
        authUrl: "https://accounts.google.com/",
        displayName: "Google",
        iconUrl: "https://logo.clearbit.com/google.com",
        sessionExtractionDomains: [
            {
                domain: ".google.com",
            },
            {
                domain: "www.google.com",
            },
            {
                domain: "accounts.google.com",
            },
            {
                domain: ".ogs.google.com",
            },
            {
                domain: "myactivity.google.com",
            },
            {
                domain: "mail.google.com",
            },
            {
                domain: "chat.google.com",
            },
            {
                domain: "contacts.google.com",
            },
            {
                domain: "drive.google.com",
            },
            {
                domain: "docs.google.com",
            },
        ],
        domCompletionIndicator: "//div[text()='Home']",
        sessionValidation: {
            sessionValidityChecks: [
                {
                    url: "https://myaccount.google.com/",
                    criteria: [
                        {
                            selector: "//div[text()='Home']",
                            exists: true,
                        },
                    ],
                    matchRule: exports.WebValidationMatchRule.ANY,
                },
            ],
        },
        completionIndicators: [
            {
                storage: "cookie",
                key: "__Secure-1PSIDCC",
                domains: [".google.com", "accounts.google.com"],
            },
        ],
    },
};

// https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/cookies/SameSiteStatus
// Lowercase enum variants are for chrome, which brings along the additional `unspecified` and `no_restriction`
// variants, whereas iOS/webkit uses `null` values and capitalized variants. Thus `Unspecified` and `No_Restriction`
// do not exist since chrome does not use them and they both map to the `null` variant (which may be interpreted
// in different ways by different browsers)
const SameSitePolicySchema = zod.z.enum([
    "unspecified",
    "no_restriction",
    "Lax",
    "lax",
    "Strict",
    "strict",
    "None",
    "none",
]);
// Copied from https://github.com/microsoft/playwright/blob/810382c074fb94ba2ac3f2b399a463d96dc3ef1f/packages/playwright-core/types/types.d.ts#L20069
const CookieSchema = zod.z.object({
    name: zod.z.string(),
    value: zod.z.string(),
    domain: zod.z.string(),
    path: zod.z.string(),
    // Unix time in seconds
    expires: zod.z.number().optional(),
    secure: zod.z.boolean(),
    // Keys that are different between browsers
    hostOnly: zod.z.boolean().optional(),
    httpOnly: zod.z.boolean().optional(),
    discard: zod.z.boolean().optional(),
    session: zod.z.boolean().optional(),
    partitioned: zod.z.boolean().optional(),
    sameSite: SameSitePolicySchema.optional(),
    sameSitePolicy: SameSitePolicySchema.optional(),
    storeId: zod.z.string().optional(),
});
const BrowserStorageSchema = zod.z.array(zod.z.array(zod.z.string()));
const SessionIdSchema = zod.z.string();
const SessionStatusSchema = zod.z.enum(["active", "revoked", "unknown"]);
const SessionSchema = zod.z.object({
    // allow id and status to not be included in return type of services
    id: zod.z.string().optional(),
    status: SessionStatusSchema.optional(),
    cookies: zod.z.array(CookieSchema),
    localStorage: BrowserStorageSchema,
    sessionStorage: BrowserStorageSchema,
    // Proxy Id generated from proxy service
    proxyId: zod.z.string().optional(),
    url: zod.z.string(),
});
// FIXME (kai) this is a redefinition of from org-types
// which should be removed.
// THIS WILL CREATE PROBLEMS
// NEED A TICKET TO TRACK THIS
const SessionAccessGrantSchema = zod.z.object({
    id: zod.z.string(),
    role: zod.z.enum(["admin", "reader", "writer"]),
    sessionId: zod.z.string(),
    subjectId: zod.z.string(),
    subjectKind: zod.z.enum(["sdkClientKind", "user"]),
});
const SessionDataSchema = zod.z.object({
    ownerId: zod.z.string().optional(),
    domain: zod.z.string(),
    session: SessionSchema,
});
const SessionRequestSchema = zod.z.object({
    app: zod.z.string(),
    authUrl: zod.z.string(),
    completionIndicators: zod.z.array(SessionCompletionIndicatorSchema),
});
const SessionAppUserSchema = zod.z.object({
    id: zod.z.string().optional(),
    anonId: zod.z.string(),
    email: zod.z.string().optional(),
});
const SessionMetadataSchema = zod.z.object({
    app: zod.z.string(),
    sessionId: zod.z.string(),
    appUser: SessionAppUserSchema,
    // TODO(kai) implement these fields
    // status: SessionStatusSchema,
    // createdAt: z.date()
    // updatedAt: z.date()
});
const SessionListResponseSchema = zod.z.object({
    sessions: zod.z.array(SessionMetadataSchema),
});
const CreateSessionAccessGrantRequestSchema = zod.z.object({
    sessionId: zod.z.string(),
    appUserId: zod.z.string(),
});
const DeleteSessionAccessGrantRequestSchema = zod.z.object({
    sessionId: zod.z.string(),
    appUserId: zod.z.string(),
});

const iOSPushNotificationRequestSchema = zod.z.object({
    iosPushAuthorization: zod.z.object({
        iosAppId: zod.z.string(),
        authToken: zod.z.string(),
    }),
    account: zod.z.object({
        ownerId: zod.z.string(),
        domain: zod.z.string(),
    }),
    appSdkClientId: zod.z.string(),
    alertBody: zod.z.string().optional(),
    alertTitle: zod.z.string().optional(),
});
// FIXME: this is currently unused by downstream sdks and account-svc doesn't handle it
const ChromePushNotificationRequestSchema = zod.z.object({
    appUserId: zod.z.string(),
    app: zod.z.string(),
});
const PushNotificationRequestSchema = iOSPushNotificationRequestSchema.or(ChromePushNotificationRequestSchema);
const iOSPushNotificationPayloadSchema = zod.z.object({
    account: zod.z.object({
        ownerId: zod.z.string(),
        domain: zod.z.string(),
    }),
    appSdkClientId: zod.z.string(),
    iosAppId: zod.z.string(),
    authenticationToken: zod.z.string(),
    alertTitle: zod.z.string().optional(),
    alertBody: zod.z.string().optional(),
    //pushType: z.string().optional()
});
const ChromePushNotificationPayloadSchema = zod.z.object({
    appUserId: zod.z.string(),
    app: zod.z.string(),
});
const PushNotificationErrorDetailsSchema = zod.z.object({
    appUserId: zod.z.string(),
    appSdkClientId: zod.z.string(),
    domain: zod.z.string().optional(),
    orgSvcStatusCode: zod.z.number().optional(),
});
const PushNotificationResponseSchema = zod.z.object({
    succeeded: zod.z.boolean(),
    appUserId: zod.z.string(),
    appSdkClientId: zod.z.string(),
    domain: zod.z.string().optional(),
});

const LocalProxyConfigSchema = zod.z.object({
    /**
     * Proxy to be used for all requests. HTTP and SOCKS proxies are supported, for example `http://myproxy.com:3128` or
     * `socks5://myproxy.com:3128`. Short form `myproxy.com:3128` is considered an HTTP proxy.
     */
    server: zod.z.string(),
    /**
     * Optional comma-separated domains to bypass proxy, for example `".com, chromium.org, .domain.com"`.
     */
    bypass: zod.z.string().optional(),
    /**
     * Optional username to use if HTTP proxy requires authentication.
     */
    username: zod.z.string().optional(),
    /**
     * Optional password to use if HTTP proxy requires authentication.
     */
    password: zod.z.string().optional(),
});
const CreateManagedAnonEnvironmentRequestSchema = zod.z
    .object({
    proxy: LocalProxyConfigSchema.optional(),
    isLiveStreamingSession: zod.z.boolean().optional(),
})
    .nullable();

// TODO: put this API on it's own file.
const AnonEnvironmentSchema = zod.z.enum([
    "local",
    "development",
    "staging",
    "sandbox",
    "prod",
]);
const LocalBrowserConfigSchema = zod.z.object({
    browserType: zod.z.literal("local"),
    isHeadless: zod.z.boolean().optional(),
    proxy: zod.z
        .object({
        isAnonProxyEnabled: zod.z.boolean(),
    })
        .optional(),
});
const BrowserbaseSessionSchema = zod.z.object({
    sessionId: zod.z.string(),
    sessionUrl: zod.z.string().optional(),
});
const ManagedBrowserConfigSchema = zod.z.object({
    browserType: zod.z.literal("managed"),
    proxy: zod.z
        .object({
        isAnonProxyEnabled: zod.z.boolean(),
    })
        .optional(),
    browserbase: BrowserbaseSessionSchema.optional(),
});
const RemoteBrowserConfigSchema = zod.z.object({
    browserType: zod.z.literal("remote"),
});
const InferredRuntimeBrowserConfigSchema = zod.z.object({
    browserType: zod.z.literal("inferred"),
    proxy: zod.z
        .object({
        ip: zod.z.string().ip(),
        username: zod.z.string().optional(),
    })
        .optional(),
    connectionUrl: zod.z.string().optional(),
});
const BaseRuntimeResultSchema = zod.z.object({
    type: zod.z.enum(["success", "error"]),
    // Unix time in milliseconds
    startSdkTime: zod.z.number(),
});
const SuccessRuntimeResultSchema = BaseRuntimeResultSchema.extend({
    type: zod.z.literal("success"),
    // Unix time in milliseconds
    startRuntimeExecutionTime: zod.z.number(),
    // Unix time in milliseconds
    endRuntimeExecutionTime: zod.z.number(),
});
const FailedToInjectSchema = BaseRuntimeResultSchema.extend({
    type: zod.z.literal("error"),
    classification: zod.z.literal("failedToInjectSession"),
    error: zod.z.string(),
});
const RuntimePlaywrightErrorSchema = FailedToInjectSchema.extend({
    type: zod.z.literal("error"),
    classification: zod.z.literal("runtimePlaywrightError"),
    // Unix time in milliseconds
    startRuntimeExecutionTime: zod.z.number(),
    // Unix time in milliseconds
    endRuntimeExecutionTime: zod.z.number(),
});
const OtherErrorSchema = FailedToInjectSchema.extend({
    type: zod.z.literal("error"),
    classification: zod.z.literal("other"),
    // Unix time in seconds
    startRuntimeExecutionTime: zod.z.number().optional(),
    // Unix time in seconds
    endRuntimeExecutionTime: zod.z.number().optional(),
});
const RuntimeResultSchema = zod.z.union([
    SuccessRuntimeResultSchema,
    FailedToInjectSchema,
    RuntimePlaywrightErrorSchema,
    OtherErrorSchema,
]);
const UserMetadataSchema = zod.z.object({
    anonSessionId: zod.z.string(),
    anonUserId: zod.z.string(),
    externalUserId: zod.z.string(),
    orgId: zod.z.string(),
    orgName: zod.z.string(),
    sdkClientId: zod.z.string(),
    sdkClientName: zod.z.string(),
    sessionCollectionTime: zod.z.date().optional(),
});
const makeRuntimeLogSchema = (userMetadataSchema, browserConfigSchema) => zod.z.object({
    environment: AnonEnvironmentSchema,
    userMetadata: userMetadataSchema,
    browserConfig: browserConfigSchema,
    app: zod.z.string(),
    runtimeResult: RuntimeResultSchema,
});
const BrowserConfigSchema = zod.z.discriminatedUnion("browserType", [
    ManagedBrowserConfigSchema,
    LocalBrowserConfigSchema,
    RemoteBrowserConfigSchema,
]);
const CreateUserMetadataSchema = zod.z.object({
    anonSessionId: zod.z.string(),
    externalUserId: zod.z.string(),
});
const RuntimeLogSchema = makeRuntimeLogSchema(UserMetadataSchema, BrowserConfigSchema);
const BrowserConfigCreateRequestSchema = zod.z.discriminatedUnion("browserType", [
    ManagedBrowserConfigSchema,
    LocalBrowserConfigSchema,
    RemoteBrowserConfigSchema,
    InferredRuntimeBrowserConfigSchema,
]);
/**
 * Schema to create a new runtime logs record. There are subtle difference in this creation payload over the
 * RuntimeLogSchema. Namely, it's meant to make creation easier and infer data for the RuntimeLog on th server side
 */
const RuntimeLogCreateRequestSchema = makeRuntimeLogSchema(CreateUserMetadataSchema, BrowserConfigCreateRequestSchema);

exports.AnonEnvironmentSchema = AnonEnvironmentSchema;
exports.AppIntegrationConfigRegistry = AppIntegrationConfigRegistry;
exports.BaseIndicatorSchema = BaseIndicatorSchema;
exports.BrowserStorageSchema = BrowserStorageSchema;
exports.ChromePushNotificationPayloadSchema = ChromePushNotificationPayloadSchema;
exports.ChromePushNotificationRequestSchema = ChromePushNotificationRequestSchema;
exports.CookieIndicatorSchema = CookieIndicatorSchema;
exports.CookieSchema = CookieSchema;
exports.CreateManagedAnonEnvironmentRequestSchema = CreateManagedAnonEnvironmentRequestSchema;
exports.CreateSessionAccessGrantRequestSchema = CreateSessionAccessGrantRequestSchema;
exports.DeleteSessionAccessGrantRequestSchema = DeleteSessionAccessGrantRequestSchema;
exports.LocalBrowserConfigSchema = LocalBrowserConfigSchema;
exports.LocalOrSessionIndicatorSchema = LocalOrSessionIndicatorSchema;
exports.LocalProxyConfigSchema = LocalProxyConfigSchema;
exports.ManagedBrowserConfigSchema = ManagedBrowserConfigSchema;
exports.PushNotificationErrorDetailsSchema = PushNotificationErrorDetailsSchema;
exports.PushNotificationRequestSchema = PushNotificationRequestSchema;
exports.PushNotificationResponseSchema = PushNotificationResponseSchema;
exports.RemoteBrowserConfigSchema = RemoteBrowserConfigSchema;
exports.RuntimeLogCreateRequestSchema = RuntimeLogCreateRequestSchema;
exports.RuntimeLogSchema = RuntimeLogSchema;
exports.RuntimeResultSchema = RuntimeResultSchema;
exports.SameSitePolicySchema = SameSitePolicySchema;
exports.SessionAccessGrantSchema = SessionAccessGrantSchema;
exports.SessionAppUserSchema = SessionAppUserSchema;
exports.SessionCompletionIndicatorSchema = SessionCompletionIndicatorSchema;
exports.SessionDataSchema = SessionDataSchema;
exports.SessionIdSchema = SessionIdSchema;
exports.SessionListResponseSchema = SessionListResponseSchema;
exports.SessionMetadataSchema = SessionMetadataSchema;
exports.SessionRequestSchema = SessionRequestSchema;
exports.SessionSchema = SessionSchema;
exports.SessionStatusSchema = SessionStatusSchema;
exports.StorageTypeSchema = StorageTypeSchema;
exports.UserMetadataSchema = UserMetadataSchema;
exports.iOSPushNotificationPayloadSchema = iOSPushNotificationPayloadSchema;
exports.iOSPushNotificationRequestSchema = iOSPushNotificationRequestSchema;
