'use strict';

var playwrightExtra = require('playwright-extra');
var puppeteerPlugin = require('puppeteer-extra-plugin-stealth');
var zod = require('zod');

const managedBrowserEnvironmentInputSchema = zod.z.object({
    apiKey: zod.z.string(),
    env: zod.z.string(),
    // NOTE: This had to be duplicated from LocalProxyConfig because there some weird type errors from zod using nested objects
    proxy: zod.z
        .object({
        server: zod.z.string(),
        bypass: zod.z.string().optional(),
        username: zod.z.string().optional(),
        password: zod.z.string().optional(),
    })
        .optional(),
});
const managedBrowserEnvironmentError = new Error(`Failed to fetch a managed browser environment from Anon`);
async function getBrowserRuntimeEnvironment(input) {
    const parsedInput = anonParse(managedBrowserEnvironmentInputSchema, input);
    const protocol = input.env === "local" ? "http" : "https";
    const url = `${protocol}://svc.${parsedInput.env}.anon.com/account/api/v1/browser/environment`;
    const res = await fetch(url, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${parsedInput.apiKey}`,
        },
        body: JSON.stringify(parsedInput),
    }).catch((e) => {
        throw managedBrowserEnvironmentError;
    });
    if (!res.ok) {
        throw managedBrowserEnvironmentError;
    }
    return (await res.json());
}
async function initializeAnonLocalBrowser(input) {
    playwrightExtra.chromium.use(puppeteerPlugin());
    let browser;
    if (input.proxy && "server" in input.proxy) {
        const proxy = input.proxy;
        browser = await playwrightExtra.chromium.launch({ ...input, proxy });
    }
    else {
        const { proxy, ...launchOptions } = input;
        browser = await playwrightExtra.chromium.launch(launchOptions);
    }
    return proxyBrowser(browser, { type: "local", input });
}
async function initializeAnonManagedBrowser(input) {
    const runtimeEnvironment = await getBrowserRuntimeEnvironment(input);
    const browser = await playwrightExtra.chromium.connectOverCDP(runtimeEnvironment.environment.connectUrl);
    return proxyBrowser(browser, {
        type: "managed",
        input: { ...input, runtimeEnvironment },
    });
}
async function initializeAnonRemoteBrowser(input) {
    const browser = await playwrightExtra.chromium.connectOverCDP(input);
    return proxyBrowser(browser, { type: "remote", input });
}
async function initializeAnonBrowser(options) {
    if (options.type === "local") {
        return await initializeAnonLocalBrowser(options.input);
    }
    else if (options.type === "managed") {
        return await initializeAnonManagedBrowser(options.input);
    }
    else if (options.type === "remote" || options.type === "self-hosted") {
        return await initializeAnonRemoteBrowser(options.input);
    }
    else {
        throw new Error(`Cannot initialize Anon Browser that is of type: ${JSON.stringify(options)}`);
    }
}
async function setupAnonBrowserContext(browser, proxy, // HACK: We have two types of proxies, LocalProxyConfig and Proxy, for backwards compatibility
contextOptions) {
    // transfer cookies to browserContext
    const browserContextInput = {
        ...(contextOptions || {}),
        ...(proxy
            ? { proxy: "id" in proxy ? extractProxyConfig(proxy) : proxy }
            : {}),
    };
    const browserContext = await browser.newContext(browserContextInput);
    return browserContext;
}
async function setupAnonBrowserWithContext(browserLaunchOptions, proxy, // HACK: We have two types of proxies, LocalProxyConfig and Proxy, for backwards compatibility
contextOptions) {
    const browser = await initializeAnonBrowser(browserLaunchOptions);
    const browserContext = await setupAnonBrowserContext(browser, proxy, contextOptions);
    return { browser, browserContext };
}
async function addAnonSession(page, session) {
    try {
        const playwrightCookie = session.cookies.map((cookie) => makePlaywrightCookie(cookie));
        await page.context().addCookies(playwrightCookie);
    }
    catch (error) {
        throw new FailedToAddSessionError("Failed to add cookies", session.id, error);
    }
    try {
        const setStorage = (type, storage) => `
      for (const [k, v] of ${JSON.stringify(storage)}) {
        ${type}.setItem(k, v);
      }
    `;
        await page.evaluate(setStorage("localStorage", session.localStorage));
        await page.evaluate(setStorage("sessionStorage", session.sessionStorage));
        await page.reload();
    }
    catch (error) {
        throw new FailedToAddSessionError("Failed to add session", session.id, error);
    }
}
function makePlaywrightCookie(cookie) {
    return {
        ...cookie,
        // HACK: playwright would still process cookies with an expires field that are none
        expires: cookie.expires,
        httpOnly: cookie.httpOnly ?? false,
        sameSite: cookie.sameSite,
    };
}
function anonParse(schema, input) {
    const result = schema.safeParse(input);
    if (result.success) {
        return result.data;
    }
    else {
        throw new Error(`Invalid input:`, result.error);
    }
}
function extractProxyConfig(proxy) {
    if (!proxy)
        return;
    const regex = /^([^:]+):\/\/([^:]+):([^@]+)@([^:]+):(\d+)$/;
    const match = proxy.proxy_url.match(regex);
    if (match) {
        const [_wholeStringMatch, protocol, username, password, host, port] = match;
        const server = `${protocol}://${host}:${port}`;
        return {
            server,
            username,
            password,
        };
    }
    else {
        const parsedUrl = new URL(proxy.proxy_url);
        const username = parsedUrl.username;
        const password = parsedUrl.password;
        const server = `${parsedUrl.protocol}://${parsedUrl.host}`;
        return { server, username, password };
    }
}
class FailedToAddSessionError extends Error {
    sessionId;
    cause;
    constructor(message, sessionId, cause) {
        super(message);
        this.sessionId = sessionId;
        this.cause = cause;
        this.name = "FailedToAddSessionError";
        // This line is necessary for proper prototype chain setup in TypeScript
        Object.setPrototypeOf(this, FailedToAddSessionError.prototype);
        // Captures the stack trace, excluding the constructor call from it
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, FailedToAddSessionError);
        }
    }
}
// Inserts Anon browser config into the browser object
function proxyBrowser(browser, browserConfig) {
    return new Proxy(browser, {
        get(target, prop, receiver) {
            if (prop === "newContext") {
                // Proxy the newContext method
                return async function (...args) {
                    // @ts-ignore
                    const context = await target.newContext.apply(target, args);
                    return proxyBrowserContext(context, browserConfig);
                };
            }
            else if (prop === "newPage") {
                // Proxy the newPage method
                return async function (...args) {
                    // newPage is a convenience method that creates a new context and page
                    // @ts-ignore
                    const page = await target.newPage.apply(target, args);
                    // Since newPage creates a new context, we need to proxy that context
                    const context = page.context();
                    // Proxy the context
                    proxyBrowserContext(context, browserConfig);
                    // Since the page is already created, we can proxy it directly
                    const proxiedPage = proxyPage(page, browserConfig);
                    return proxiedPage;
                };
            }
            else if (prop === "contexts") {
                // Proxy the contexts method
                return function (...args) {
                    // @ts-ignore
                    const contexts = target.contexts.apply(target, args);
                    return contexts.map((context) => proxyBrowserContext(context, browserConfig));
                };
            }
            else {
                // Default behavior for other properties/methods
                // @ts-ignore
                const origProp = target[prop];
                if (typeof origProp === "function") {
                    return origProp.bind(target);
                }
                else if (prop === "browserConfig") {
                    return browserConfig;
                }
                else {
                    return origProp;
                }
            }
        },
    });
}
// Inserts Anon browser config into the browserContext object
function proxyBrowserContext(browserContext, browserConfig) {
    return new Proxy(browserContext, {
        get(target, prop, receiver) {
            if (prop === "newPage") {
                // Proxy the newPage method
                return async function (...args) {
                    // @ts-ignore
                    const page = await target.newPage.apply(target, args);
                    return proxyPage(page, browserConfig);
                };
            }
            else if (prop === "pages") {
                // Proxy the pages method
                return function (...args) {
                    // @ts-ignore
                    const pages = target.pages.apply(target, args);
                    return pages.map((page) => proxyPage(page, browserConfig));
                };
            }
            else if (prop === "on" || prop === "addListener") {
                // Proxy the event listener methods
                return function (eventName, callback) {
                    if (eventName === "page") {
                        // Wrap the callback to proxy the page
                        const wrappedCallback = (page) => {
                            const proxiedPage = proxyPage(page, browserConfig);
                            callback(proxiedPage);
                        };
                        // @ts-ignore
                        target.on.call(target, eventName, wrappedCallback);
                    }
                    else {
                        // @ts-ignore
                        target.on.call(target, eventName, callback);
                    }
                };
            }
            else if (prop === "browserConfig") {
                return browserConfig;
            }
            else {
                // Default behavior for other properties/methods
                // @ts-ignore
                const origProp = target[prop];
                if (typeof origProp === "function") {
                    return origProp.bind(target);
                }
                else {
                    return origProp;
                }
            }
        },
    });
}
// Inserts Anon browser config into the page object
function proxyPage(page, browserConfig) {
    return new Proxy(page, {
        get(target, prop, receiver) {
            if (prop === "browserConfig") {
                return browserConfig;
            }
            else {
                // @ts-ignore
                const origProp = target[prop];
                if (typeof origProp === "function") {
                    return origProp.bind(target);
                }
                else {
                    return origProp;
                }
            }
        },
    });
}

exports.FailedToAddSessionError = FailedToAddSessionError;
exports.addAnonSession = addAnonSession;
exports.extractProxyConfig = extractProxyConfig;
exports.getBrowserRuntimeEnvironment = getBrowserRuntimeEnvironment;
exports.initializeAnonBrowser = initializeAnonBrowser;
exports.initializeAnonLocalBrowser = initializeAnonLocalBrowser;
exports.initializeAnonManagedBrowser = initializeAnonManagedBrowser;
exports.initializeAnonRemoteBrowser = initializeAnonRemoteBrowser;
exports.makePlaywrightCookie = makePlaywrightCookie;
exports.managedBrowserEnvironmentInputSchema = managedBrowserEnvironmentInputSchema;
exports.proxyBrowser = proxyBrowser;
exports.setupAnonBrowserContext = setupAnonBrowserContext;
exports.setupAnonBrowserWithContext = setupAnonBrowserWithContext;
